/* SCAPStub.h
   Generated by gSOAP 2.8.28 from SCAP-Services.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <deque>
#include <list>
#include <vector>
#include <set>
#define SOAP_NAMESPACE_OF_ns5	"http://www.w3.org/2000/09/xmldsig#"
#define SOAP_NAMESPACE_OF_ns1	"http://uri.etsi.org/01903/v1.3.2#"
#define SOAP_NAMESPACE_OF_ns7	"http://www.cartaodecidadao.pt/ccc/commons/messages/SVG"
#define SOAP_NAMESPACE_OF_ns2	"http://www.cartaodecidadao.pt/ccc/sccc/services/AttributeSupplierService"
#define SOAP_NAMESPACE_OF_ns3	"http://www.cartaodecidadao.pt/ccc/sccc/messages/AttributeSupplierService"
#define SOAP_NAMESPACE_OF_ns4	"http://www.cartaodecidadao.pt/ccc/sccc/services/PDFSignature"
#define SOAP_WSA_200408

#ifndef SCAPStub_H
#define SCAPStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20828
# error "GSOAP VERSION 20828 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


/* SCAP-Services.h:736 */
#ifndef SOAP_TYPE_ns4__SignatureOrientationEnumType
#define SOAP_TYPE_ns4__SignatureOrientationEnumType (134)
/* ns4:SignatureOrientationEnumType */
enum ns4__SignatureOrientationEnumType
{
	ns4__SignatureOrientationEnumType__LANDSCAPE = 0,
	ns4__SignatureOrientationEnumType__PORTRAIT = 1
};
#endif

/* wsa.h:119 */
#ifndef SOAP_TYPE_wsa__RelationshipTypeValues
#define SOAP_TYPE_wsa__RelationshipTypeValues (311)
/* wsa:RelationshipTypeValues */
enum wsa__RelationshipTypeValues
{
	wsa__Reply = 0
};
#endif

/* wsa.h:127 */
#ifndef SOAP_TYPE_wsa__FaultSubcodeValues
#define SOAP_TYPE_wsa__FaultSubcodeValues (312)
/* wsa:FaultSubcodeValues */
enum wsa__FaultSubcodeValues
{
	wsa__InvalidMessageInformationHeader = 0,
	wsa__MessageInformationHeaderRequired = 1,
	wsa__DestinationUnreachable = 2,
	wsa__ActionNotSupported = 3,
	wsa__EndpointUnavailable = 4
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs, and Unions                                               *
 *                                                                            *
\******************************************************************************/

class xsd__base64Binary;	/* SCAP-Services.h:197 */
class ns2__AttributeRequestType;	/* SCAP-Services.h:225 */
class ns2__SingleAttributeRequestType;	/* SCAP-Services.h:228 */
class ns2__PSAAttributeRequestType;	/* SCAP-Services.h:231 */
class ns2__AttributeSupplierListType;	/* SCAP-Services.h:234 */
class ns2__AttributeResponseType;	/* SCAP-Services.h:237 */
class ns2__SingleAttributeResponseType;	/* SCAP-Services.h:240 */
class ns2__UnsignedAttributeResponseType;	/* SCAP-Services.h:243 */
class ns2__AttributesType;	/* SCAP-Services.h:246 */
class ns2__UnsignedAttributesType;	/* SCAP-Services.h:249 */
class ns2__SignedAttributesType;	/* SCAP-Services.h:252 */
class ns2__UnsignedAttributesBasicType;	/* SCAP-Services.h:255 */
class ns2__ResponseResult;	/* SCAP-Services.h:258 */
class ns5__SignatureType;	/* SCAP-Services.h:261 */
class ns5__SignedInfoType;	/* SCAP-Services.h:264 */
class ns5__CanonicalizationMethodType;	/* SCAP-Services.h:267 */
class ns5__SignatureMethodType;	/* SCAP-Services.h:270 */
class ns5__ReferenceType;	/* SCAP-Services.h:273 */
class ns5__TransformsType;	/* SCAP-Services.h:276 */
class ns5__TransformType;	/* SCAP-Services.h:279 */
class ns5__DigestMethodType;	/* SCAP-Services.h:282 */
class ns5__KeyInfoType;	/* SCAP-Services.h:285 */
class ns5__X509DataType;	/* SCAP-Services.h:288 */
union _ns5__union_ObjectType;	/* SCAP-Services.h:1294 */
class ns5__ObjectType;	/* SCAP-Services.h:291 */
class ns3__AttributeType;	/* SCAP-Services.h:303 */
class ns3__AttributeSupplierType;	/* SCAP-Services.h:306 */
class ns3__PersonalDataType;	/* SCAP-Services.h:309 */
class ns3__ExtraIDListType;	/* SCAP-Services.h:312 */
class ns3__ExtraIDType;	/* SCAP-Services.h:315 */
class ns3__MainAttributeType;	/* SCAP-Services.h:318 */
class ns3__LegalActListType;	/* SCAP-Services.h:321 */
class ns3__SubAttributeListType;	/* SCAP-Services.h:324 */
class ns3__SubAttributeType;	/* SCAP-Services.h:327 */
class ns3__ResponseCodeStatusType;	/* SCAP-Services.h:330 */
class ns1__QualifyingPropertiesType;	/* SCAP-Services.h:333 */
class ns1__SignedPropertiesType;	/* SCAP-Services.h:336 */
class ns1__SignedSignaturePropertiesType;	/* SCAP-Services.h:339 */
class ns1__SigningCertificateType;	/* SCAP-Services.h:342 */
class ns1__CertType;	/* SCAP-Services.h:345 */
class ns1__CertDigestType;	/* SCAP-Services.h:348 */
class ns1__IssuerSerialType;	/* SCAP-Services.h:351 */
class ns1__SignerRoleType;	/* SCAP-Services.h:354 */
class ns1__ClaimedRolesListType;	/* SCAP-Services.h:357 */
class ns1__ClaimedRoleType;	/* SCAP-Services.h:360 */
class ns1__UnsignedPropertiesType;	/* SCAP-Services.h:363 */
class ns1__UnsignedSignaturePropertiesType;	/* SCAP-Services.h:366 */
class ns1__CounterSignatureType;	/* SCAP-Services.h:369 */
class ns1__SignatureTimeStampType;	/* SCAP-Services.h:372 */
class ns1__CompleteCertificateRefsType;	/* SCAP-Services.h:375 */
class ns1__CertRefsType;	/* SCAP-Services.h:378 */
class ns1__CompleteRevocationRefsType;	/* SCAP-Services.h:381 */
class ns1__CRLRefsType;	/* SCAP-Services.h:384 */
class ns1__CRLRefType;	/* SCAP-Services.h:387 */
class ns1__DigestAlgAndValueType;	/* SCAP-Services.h:390 */
class ns1__CRLIdentifierType;	/* SCAP-Services.h:393 */
class ns1__OCSPRefsType;	/* SCAP-Services.h:396 */
class ns1__OCSPRefType;	/* SCAP-Services.h:399 */
class ns1__OCSPIdentifierType;	/* SCAP-Services.h:402 */
class ns1__ResponderIDType;	/* SCAP-Services.h:405 */
class ns1__SigAndRefsTimeStampType;	/* SCAP-Services.h:408 */
class ns1__CertificateValuesType;	/* SCAP-Services.h:411 */
class ns1__RevocationValuesType;	/* SCAP-Services.h:417 */
class ns1__CRLValuesType;	/* SCAP-Services.h:420 */
class ns1__OCSPValuesType;	/* SCAP-Services.h:426 */
class ns1__ArchiveTimeStampType;	/* SCAP-Services.h:432 */
class ns7__SVGListType;	/* SCAP-Services.h:450 */
class ns3__AttributeSupplierResponseType;	/* SCAP-Services.h:453 */
class ns4__SignRequest;	/* SCAP-Services.h:456 */
class ns4__PersonalDataType;	/* SCAP-Services.h:459 */
class ns4__AttributeListType;	/* SCAP-Services.h:462 */
class ns4__AttributeType;	/* SCAP-Services.h:465 */
class ns4__AttributeSupplierType;	/* SCAP-Services.h:468 */
class ns4__MainAttributeType;	/* SCAP-Services.h:471 */
class ns4__LegalActListType;	/* SCAP-Services.h:474 */
class ns4__SubAttributeListType;	/* SCAP-Services.h:477 */
class ns4__SubAttributeType;	/* SCAP-Services.h:480 */
class ns4__SignResponse;	/* SCAP-Services.h:483 */
class ns4__Status;	/* SCAP-Services.h:486 */
class ns5__X509CertificateType;	/* SCAP-Services.h:294 */
class ns5__DigestValueType;	/* SCAP-Services.h:297 */
class ns5__SignatureValueType;	/* SCAP-Services.h:300 */
class ns1__EncapsulatedX509CertificateType;	/* SCAP-Services.h:414 */
class ns1__EncapsulatedCRLValueType;	/* SCAP-Services.h:423 */
class ns1__EncapsulatedOCSPValueType;	/* SCAP-Services.h:429 */
struct wsa__EndpointReferenceType;	/* wsa.h:94 */
struct wsa__ReferencePropertiesType;	/* wsa.h:97 */
struct wsa__ReferenceParametersType;	/* wsa.h:100 */
struct wsa__ServiceNameType;	/* wsa.h:103 */
struct wsa__Relationship;	/* wsa.h:106 */
struct __ns1__Attributes;	/* SCAP-Services.h:3251 */
struct __ns2__AttributeSuppliers;	/* SCAP-Services.h:3332 */
struct __ns4__Sign;	/* SCAP-Services.h:3416 */

/* SCAP-Services.h:197 */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (11)
/* base64Binary schema type: */
class SOAP_CMAC xsd__base64Binary
{
public:
	unsigned char *__ptr;
	int __size;
	char *id;	/* optional element of XSD type xsd:string */
	char *type;	/* optional element of XSD type xsd:string */
	char *options;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__base64Binary (11)
	virtual int soap_type(void) const { return 11; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__base64Binary, default initialized and not managed by a soap context
	virtual xsd__base64Binary *soap_alloc(void) const { return SOAP_NEW(xsd__base64Binary); }
	         xsd__base64Binary() { xsd__base64Binary::soap_default(NULL); }
	virtual ~xsd__base64Binary() { }
	friend SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:225 */
#ifndef SOAP_TYPE_ns2__AttributeRequestType
#define SOAP_TYPE_ns2__AttributeRequestType (21)
/* ns2:AttributeRequestType complex type: */
class SOAP_CMAC ns2__AttributeRequestType
{
public:
	std::string ProcessId;	/* required element of XSD type ns4:ProcessIDType */
	ns3__PersonalDataType *Citizen;	/* required element of XSD type ns3:PersonalDataType */
	ns2__AttributeSupplierListType *AttributeSuppliers;	/* required element of XSD type ns2:AttributeSupplierListType */
	bool *AllEnterprises;	/* optional element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns2__AttributeRequestType (21)
	virtual int soap_type(void) const { return 21; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns2__AttributeRequestType, default initialized and not managed by a soap context
	virtual ns2__AttributeRequestType *soap_alloc(void) const { return SOAP_NEW(ns2__AttributeRequestType); }
	         ns2__AttributeRequestType() { ns2__AttributeRequestType::soap_default(NULL); }
	virtual ~ns2__AttributeRequestType() { }
	friend SOAP_FMAC1 ns2__AttributeRequestType * SOAP_FMAC2 soap_instantiate_ns2__AttributeRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:228 */
#ifndef SOAP_TYPE_ns2__SingleAttributeRequestType
#define SOAP_TYPE_ns2__SingleAttributeRequestType (22)
/* ns2:SingleAttributeRequestType complex type: */
class SOAP_CMAC ns2__SingleAttributeRequestType
{
public:
	std::string ProcessId;	/* required element of XSD type ns4:ProcessIDType */
	ns3__PersonalDataType *Citizen;	/* required element of XSD type ns3:PersonalDataType */
	ns3__AttributeSupplierType *AttributeSuppliers;	/* required element of XSD type ns3:AttributeSupplierType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns2__SingleAttributeRequestType (22)
	virtual int soap_type(void) const { return 22; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns2__SingleAttributeRequestType, default initialized and not managed by a soap context
	virtual ns2__SingleAttributeRequestType *soap_alloc(void) const { return SOAP_NEW(ns2__SingleAttributeRequestType); }
	         ns2__SingleAttributeRequestType() { ns2__SingleAttributeRequestType::soap_default(NULL); }
	virtual ~ns2__SingleAttributeRequestType() { }
	friend SOAP_FMAC1 ns2__SingleAttributeRequestType * SOAP_FMAC2 soap_instantiate_ns2__SingleAttributeRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:231 */
#ifndef SOAP_TYPE_ns2__PSAAttributeRequestType
#define SOAP_TYPE_ns2__PSAAttributeRequestType (23)
/* ns2:PSAAttributeRequestType complex type: */
class SOAP_CMAC ns2__PSAAttributeRequestType
{
public:
	std::string ProcessId;	/* required element of XSD type ns4:ProcessIDType */
	ns3__PersonalDataType *Citizen;	/* required element of XSD type ns3:PersonalDataType */
	std::string *CompanyId;	/* optional element of XSD type ns4:NIPCType */
	std::string *CompanyName;	/* optional element of XSD type ns4:CompanyNameType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns2__PSAAttributeRequestType (23)
	virtual int soap_type(void) const { return 23; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns2__PSAAttributeRequestType, default initialized and not managed by a soap context
	virtual ns2__PSAAttributeRequestType *soap_alloc(void) const { return SOAP_NEW(ns2__PSAAttributeRequestType); }
	         ns2__PSAAttributeRequestType() { ns2__PSAAttributeRequestType::soap_default(NULL); }
	virtual ~ns2__PSAAttributeRequestType() { }
	friend SOAP_FMAC1 ns2__PSAAttributeRequestType * SOAP_FMAC2 soap_instantiate_ns2__PSAAttributeRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:234 */
#ifndef SOAP_TYPE_ns2__AttributeSupplierListType
#define SOAP_TYPE_ns2__AttributeSupplierListType (24)
/* ns2:AttributeSupplierListType complex type: */
class SOAP_CMAC ns2__AttributeSupplierListType
{
public:
	std::vector<ns3__AttributeSupplierType *> AttributeSupplier;	/* required element of XSD type ns3:AttributeSupplierType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns2__AttributeSupplierListType (24)
	virtual int soap_type(void) const { return 24; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns2__AttributeSupplierListType, default initialized and not managed by a soap context
	virtual ns2__AttributeSupplierListType *soap_alloc(void) const { return SOAP_NEW(ns2__AttributeSupplierListType); }
	         ns2__AttributeSupplierListType() { ns2__AttributeSupplierListType::soap_default(NULL); }
	virtual ~ns2__AttributeSupplierListType() { }
	friend SOAP_FMAC1 ns2__AttributeSupplierListType * SOAP_FMAC2 soap_instantiate_ns2__AttributeSupplierListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:237 */
#ifndef SOAP_TYPE_ns2__AttributeResponseType
#define SOAP_TYPE_ns2__AttributeResponseType (25)
/* ns2:AttributeResponseType complex type: */
class SOAP_CMAC ns2__AttributeResponseType
{
public:
	std::string ProcessId;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type ns4:ProcessIDType */
	std::vector<ns2__AttributesType *> AttributeResponseValues;	/* required element of XSD type ns2:AttributesType */
	std::string *ErrorMessage;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns2__AttributeResponseType (25)
	virtual int soap_type(void) const { return 25; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns2__AttributeResponseType, default initialized and not managed by a soap context
	virtual ns2__AttributeResponseType *soap_alloc(void) const { return SOAP_NEW(ns2__AttributeResponseType); }
	         ns2__AttributeResponseType() { ns2__AttributeResponseType::soap_default(NULL); }
	virtual ~ns2__AttributeResponseType() { }
	friend SOAP_FMAC1 ns2__AttributeResponseType * SOAP_FMAC2 soap_instantiate_ns2__AttributeResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:240 */
#ifndef SOAP_TYPE_ns2__SingleAttributeResponseType
#define SOAP_TYPE_ns2__SingleAttributeResponseType (26)
/* ns2:SingleAttributeResponseType complex type: */
class SOAP_CMAC ns2__SingleAttributeResponseType
{
public:
	std::string ProcessId;	/* required element of XSD type ns4:ProcessIDType */
	ns2__AttributesType *AttributeResponseValues;	/* required element of XSD type ns2:AttributesType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns2__SingleAttributeResponseType (26)
	virtual int soap_type(void) const { return 26; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns2__SingleAttributeResponseType, default initialized and not managed by a soap context
	virtual ns2__SingleAttributeResponseType *soap_alloc(void) const { return SOAP_NEW(ns2__SingleAttributeResponseType); }
	         ns2__SingleAttributeResponseType() { ns2__SingleAttributeResponseType::soap_default(NULL); }
	virtual ~ns2__SingleAttributeResponseType() { }
	friend SOAP_FMAC1 ns2__SingleAttributeResponseType * SOAP_FMAC2 soap_instantiate_ns2__SingleAttributeResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:243 */
#ifndef SOAP_TYPE_ns2__UnsignedAttributeResponseType
#define SOAP_TYPE_ns2__UnsignedAttributeResponseType (27)
/* ns2:UnsignedAttributeResponseType complex type: */
class SOAP_CMAC ns2__UnsignedAttributeResponseType
{
public:
	std::string ProcessId;	/* required element of XSD type ns4:ProcessIDType */
	std::string *CompanyId;	/* optional element of XSD type ns4:NIPCType */
	std::string *CompanyName;	/* optional element of XSD type ns4:CompanyNameType */
	ns2__UnsignedAttributesType *AttributeResponseValues;	/* required element of XSD type ns2:UnsignedAttributesType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns2__UnsignedAttributeResponseType (27)
	virtual int soap_type(void) const { return 27; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns2__UnsignedAttributeResponseType, default initialized and not managed by a soap context
	virtual ns2__UnsignedAttributeResponseType *soap_alloc(void) const { return SOAP_NEW(ns2__UnsignedAttributeResponseType); }
	         ns2__UnsignedAttributeResponseType() { ns2__UnsignedAttributeResponseType::soap_default(NULL); }
	virtual ~ns2__UnsignedAttributeResponseType() { }
	friend SOAP_FMAC1 ns2__UnsignedAttributeResponseType * SOAP_FMAC2 soap_instantiate_ns2__UnsignedAttributeResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:246 */
#ifndef SOAP_TYPE_ns2__AttributesType
#define SOAP_TYPE_ns2__AttributesType (28)
/* ns2:AttributesType complex type: */
class SOAP_CMAC ns2__AttributesType
{
public:
	ns3__AttributeSupplierType *ATTRSupplier;	/* required element of XSD type ns3:AttributeSupplierType */
	ns2__ResponseResult *ResponseResult;	/* required element of XSD type ns2:ResponseResult */
	ns2__SignedAttributesType *SignedAttributes;	/* optional element of XSD type ns2:SignedAttributesType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns2__AttributesType (28)
	virtual int soap_type(void) const { return 28; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns2__AttributesType, default initialized and not managed by a soap context
	virtual ns2__AttributesType *soap_alloc(void) const { return SOAP_NEW(ns2__AttributesType); }
	         ns2__AttributesType() { ns2__AttributesType::soap_default(NULL); }
	virtual ~ns2__AttributesType() { }
	friend SOAP_FMAC1 ns2__AttributesType * SOAP_FMAC2 soap_instantiate_ns2__AttributesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:249 */
#ifndef SOAP_TYPE_ns2__UnsignedAttributesType
#define SOAP_TYPE_ns2__UnsignedAttributesType (29)
/* ns2:UnsignedAttributesType complex type: */
class SOAP_CMAC ns2__UnsignedAttributesType
{
public:
	ns2__ResponseResult *ResponseResult;	/* required element of XSD type ns2:ResponseResult */
	ns2__UnsignedAttributesBasicType *UnsignedAttributes;	/* optional element of XSD type ns2:UnsignedAttributesBasicType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns2__UnsignedAttributesType (29)
	virtual int soap_type(void) const { return 29; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns2__UnsignedAttributesType, default initialized and not managed by a soap context
	virtual ns2__UnsignedAttributesType *soap_alloc(void) const { return SOAP_NEW(ns2__UnsignedAttributesType); }
	         ns2__UnsignedAttributesType() { ns2__UnsignedAttributesType::soap_default(NULL); }
	virtual ~ns2__UnsignedAttributesType() { }
	friend SOAP_FMAC1 ns2__UnsignedAttributesType * SOAP_FMAC2 soap_instantiate_ns2__UnsignedAttributesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:252 */
#ifndef SOAP_TYPE_ns2__SignedAttributesType
#define SOAP_TYPE_ns2__SignedAttributesType (30)
/* ns2:SignedAttributesType complex type: */
class SOAP_CMAC ns2__SignedAttributesType
{
public:
	std::vector<ns5__SignatureType *> ns3__SignatureAttribute;	/* required element of XSD type ns5:SignatureType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns2__SignedAttributesType (30)
	virtual int soap_type(void) const { return 30; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns2__SignedAttributesType, default initialized and not managed by a soap context
	virtual ns2__SignedAttributesType *soap_alloc(void) const { return SOAP_NEW(ns2__SignedAttributesType); }
	         ns2__SignedAttributesType() { ns2__SignedAttributesType::soap_default(NULL); }
	virtual ~ns2__SignedAttributesType() { }
	friend SOAP_FMAC1 ns2__SignedAttributesType * SOAP_FMAC2 soap_instantiate_ns2__SignedAttributesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:255 */
#ifndef SOAP_TYPE_ns2__UnsignedAttributesBasicType
#define SOAP_TYPE_ns2__UnsignedAttributesBasicType (31)
/* ns2:UnsignedAttributesBasicType complex type: */
class SOAP_CMAC ns2__UnsignedAttributesBasicType
{
public:
	std::vector<ns3__AttributeType *> ns3__Attribute;	/* required element of XSD type ns3:AttributeType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns2__UnsignedAttributesBasicType (31)
	virtual int soap_type(void) const { return 31; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns2__UnsignedAttributesBasicType, default initialized and not managed by a soap context
	virtual ns2__UnsignedAttributesBasicType *soap_alloc(void) const { return SOAP_NEW(ns2__UnsignedAttributesBasicType); }
	         ns2__UnsignedAttributesBasicType() { ns2__UnsignedAttributesBasicType::soap_default(NULL); }
	virtual ~ns2__UnsignedAttributesBasicType() { }
	friend SOAP_FMAC1 ns2__UnsignedAttributesBasicType * SOAP_FMAC2 soap_instantiate_ns2__UnsignedAttributesBasicType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:258 */
#ifndef SOAP_TYPE_ns2__ResponseResult
#define SOAP_TYPE_ns2__ResponseResult (32)
/* ns2:ResponseResult complex type: */
class SOAP_CMAC ns2__ResponseResult
{
public:
	std::string ResultCode;	/* required element of XSD type xsd:string */
	std::string ResultMessage;	/* required element of XSD type xsd:string */
	ns3__PersonalDataType *CitizenIDWithExtraInfo;	/* required element of XSD type ns3:PersonalDataType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns2__ResponseResult (32)
	virtual int soap_type(void) const { return 32; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns2__ResponseResult, default initialized and not managed by a soap context
	virtual ns2__ResponseResult *soap_alloc(void) const { return SOAP_NEW(ns2__ResponseResult); }
	         ns2__ResponseResult() { ns2__ResponseResult::soap_default(NULL); }
	virtual ~ns2__ResponseResult() { }
	friend SOAP_FMAC1 ns2__ResponseResult * SOAP_FMAC2 soap_instantiate_ns2__ResponseResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:261 */
#ifndef SOAP_TYPE_ns5__SignatureType
#define SOAP_TYPE_ns5__SignatureType (33)
/* Type ns5__SignatureType is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns5:SignatureType complex type: */
class SOAP_CMAC ns5__SignatureType
{
public:
	ns5__SignedInfoType *ns5__SignedInfo;	/* required element of XSD type ns5:SignedInfoType */
	ns5__SignatureValueType *ns5__SignatureValue;	/* required element of XSD type ns5:SignatureValueType */
	ns5__KeyInfoType *ns5__KeyInfo;	/* required element of XSD type ns5:KeyInfoType */
	std::vector<ns5__ObjectType *> ns5__Object;	/* optional element of XSD type ns5:ObjectType */
	std::string Id;	/* required attribute of XSD type xsd:ID */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns5__SignatureType (33)
	virtual int soap_type(void) const { return 33; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns5__SignatureType, default initialized and not managed by a soap context
	virtual ns5__SignatureType *soap_alloc(void) const { return SOAP_NEW(ns5__SignatureType); }
	         ns5__SignatureType() { ns5__SignatureType::soap_default(NULL); }
	virtual ~ns5__SignatureType() { }
	friend SOAP_FMAC1 ns5__SignatureType * SOAP_FMAC2 soap_instantiate_ns5__SignatureType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:264 */
#ifndef SOAP_TYPE_ns5__SignedInfoType
#define SOAP_TYPE_ns5__SignedInfoType (34)
/* ns5:SignedInfoType complex type: */
class SOAP_CMAC ns5__SignedInfoType
{
public:
	ns5__CanonicalizationMethodType *ns5__CanonicalizationMethod;	/* required element of XSD type ns5:CanonicalizationMethodType */
	ns5__SignatureMethodType *ns5__SignatureMethod;	/* required element of XSD type ns5:SignatureMethodType */
	std::vector<ns5__ReferenceType *> ns5__Reference;	/* required element of XSD type ns5:ReferenceType */
	std::string Id;	/* required attribute of XSD type xsd:ID */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns5__SignedInfoType (34)
	virtual int soap_type(void) const { return 34; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns5__SignedInfoType, default initialized and not managed by a soap context
	virtual ns5__SignedInfoType *soap_alloc(void) const { return SOAP_NEW(ns5__SignedInfoType); }
	         ns5__SignedInfoType() { ns5__SignedInfoType::soap_default(NULL); }
	virtual ~ns5__SignedInfoType() { }
	friend SOAP_FMAC1 ns5__SignedInfoType * SOAP_FMAC2 soap_instantiate_ns5__SignedInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:267 */
#ifndef SOAP_TYPE_ns5__CanonicalizationMethodType
#define SOAP_TYPE_ns5__CanonicalizationMethodType (35)
/* ns5:CanonicalizationMethodType complex type: */
class SOAP_CMAC ns5__CanonicalizationMethodType
{
public:
	std::string Algorithm;	/* required attribute of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns5__CanonicalizationMethodType (35)
	virtual int soap_type(void) const { return 35; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns5__CanonicalizationMethodType, default initialized and not managed by a soap context
	virtual ns5__CanonicalizationMethodType *soap_alloc(void) const { return SOAP_NEW(ns5__CanonicalizationMethodType); }
	         ns5__CanonicalizationMethodType() { ns5__CanonicalizationMethodType::soap_default(NULL); }
	virtual ~ns5__CanonicalizationMethodType() { }
	friend SOAP_FMAC1 ns5__CanonicalizationMethodType * SOAP_FMAC2 soap_instantiate_ns5__CanonicalizationMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:270 */
#ifndef SOAP_TYPE_ns5__SignatureMethodType
#define SOAP_TYPE_ns5__SignatureMethodType (36)
/* ns5:SignatureMethodType complex type: */
class SOAP_CMAC ns5__SignatureMethodType
{
public:
	std::string Algorithm;	/* required attribute of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns5__SignatureMethodType (36)
	virtual int soap_type(void) const { return 36; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns5__SignatureMethodType, default initialized and not managed by a soap context
	virtual ns5__SignatureMethodType *soap_alloc(void) const { return SOAP_NEW(ns5__SignatureMethodType); }
	         ns5__SignatureMethodType() { ns5__SignatureMethodType::soap_default(NULL); }
	virtual ~ns5__SignatureMethodType() { }
	friend SOAP_FMAC1 ns5__SignatureMethodType * SOAP_FMAC2 soap_instantiate_ns5__SignatureMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:273 */
#ifndef SOAP_TYPE_ns5__ReferenceType
#define SOAP_TYPE_ns5__ReferenceType (37)
/* ns5:ReferenceType complex type: */
class SOAP_CMAC ns5__ReferenceType
{
public:
	ns5__TransformsType *ns5__Transforms;	/* required element of XSD type ns5:TransformsType */
	ns5__DigestMethodType *ns5__DigestMethod;	/* required element of XSD type ns5:DigestMethodType */
	ns5__DigestValueType *ns5__DigestValue;	/* required element of XSD type ns5:DigestValueType */
	std::string Id;	/* required attribute of XSD type xsd:ID */
	std::string *Type;	/* optional attribute of XSD type xsd:anyURI */
	std::string *URI;	/* optional attribute of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns5__ReferenceType (37)
	virtual int soap_type(void) const { return 37; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns5__ReferenceType, default initialized and not managed by a soap context
	virtual ns5__ReferenceType *soap_alloc(void) const { return SOAP_NEW(ns5__ReferenceType); }
	         ns5__ReferenceType() { ns5__ReferenceType::soap_default(NULL); }
	virtual ~ns5__ReferenceType() { }
	friend SOAP_FMAC1 ns5__ReferenceType * SOAP_FMAC2 soap_instantiate_ns5__ReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:276 */
#ifndef SOAP_TYPE_ns5__TransformsType
#define SOAP_TYPE_ns5__TransformsType (38)
/* ns5:TransformsType complex type: */
class SOAP_CMAC ns5__TransformsType
{
public:
	std::vector<ns5__TransformType *> ns5__Transform;	/* required element of XSD type ns5:TransformType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns5__TransformsType (38)
	virtual int soap_type(void) const { return 38; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns5__TransformsType, default initialized and not managed by a soap context
	virtual ns5__TransformsType *soap_alloc(void) const { return SOAP_NEW(ns5__TransformsType); }
	         ns5__TransformsType() { ns5__TransformsType::soap_default(NULL); }
	virtual ~ns5__TransformsType() { }
	friend SOAP_FMAC1 ns5__TransformsType * SOAP_FMAC2 soap_instantiate_ns5__TransformsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:279 */
#ifndef SOAP_TYPE_ns5__TransformType
#define SOAP_TYPE_ns5__TransformType (39)
/* ns5:TransformType complex type: */
class SOAP_CMAC ns5__TransformType
{
public:
	std::string Algorithm;	/* required attribute of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns5__TransformType (39)
	virtual int soap_type(void) const { return 39; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns5__TransformType, default initialized and not managed by a soap context
	virtual ns5__TransformType *soap_alloc(void) const { return SOAP_NEW(ns5__TransformType); }
	         ns5__TransformType() { ns5__TransformType::soap_default(NULL); }
	virtual ~ns5__TransformType() { }
	friend SOAP_FMAC1 ns5__TransformType * SOAP_FMAC2 soap_instantiate_ns5__TransformType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:282 */
#ifndef SOAP_TYPE_ns5__DigestMethodType
#define SOAP_TYPE_ns5__DigestMethodType (40)
/* ns5:DigestMethodType complex type: */
class SOAP_CMAC ns5__DigestMethodType
{
public:
	std::string Algorithm;	/* required attribute of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns5__DigestMethodType (40)
	virtual int soap_type(void) const { return 40; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns5__DigestMethodType, default initialized and not managed by a soap context
	virtual ns5__DigestMethodType *soap_alloc(void) const { return SOAP_NEW(ns5__DigestMethodType); }
	         ns5__DigestMethodType() { ns5__DigestMethodType::soap_default(NULL); }
	virtual ~ns5__DigestMethodType() { }
	friend SOAP_FMAC1 ns5__DigestMethodType * SOAP_FMAC2 soap_instantiate_ns5__DigestMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:285 */
#ifndef SOAP_TYPE_ns5__KeyInfoType
#define SOAP_TYPE_ns5__KeyInfoType (41)
/* ns5:KeyInfoType complex type: */
class SOAP_CMAC ns5__KeyInfoType
{
public:
	ns5__X509DataType *ns5__X509Data;	/* required element of XSD type ns5:X509DataType */
	std::string Id;	/* required attribute of XSD type xsd:ID */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns5__KeyInfoType (41)
	virtual int soap_type(void) const { return 41; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns5__KeyInfoType, default initialized and not managed by a soap context
	virtual ns5__KeyInfoType *soap_alloc(void) const { return SOAP_NEW(ns5__KeyInfoType); }
	         ns5__KeyInfoType() { ns5__KeyInfoType::soap_default(NULL); }
	virtual ~ns5__KeyInfoType() { }
	friend SOAP_FMAC1 ns5__KeyInfoType * SOAP_FMAC2 soap_instantiate_ns5__KeyInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:288 */
#ifndef SOAP_TYPE_ns5__X509DataType
#define SOAP_TYPE_ns5__X509DataType (42)
/* ns5:X509DataType complex type: */
class SOAP_CMAC ns5__X509DataType
{
public:
	std::vector<ns5__X509CertificateType *> ns5__X509Certificate;	/* required element of XSD type ns5:X509CertificateType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns5__X509DataType (42)
	virtual int soap_type(void) const { return 42; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns5__X509DataType, default initialized and not managed by a soap context
	virtual ns5__X509DataType *soap_alloc(void) const { return SOAP_NEW(ns5__X509DataType); }
	         ns5__X509DataType() { ns5__X509DataType::soap_default(NULL); }
	virtual ~ns5__X509DataType() { }
	friend SOAP_FMAC1 ns5__X509DataType * SOAP_FMAC2 soap_instantiate_ns5__X509DataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:1294 */
#ifndef SOAP_TYPE__ns5__union_ObjectType
#define SOAP_TYPE__ns5__union_ObjectType (174)
/* xsd:choice complex type: */
union _ns5__union_ObjectType
{
#define SOAP_UNION__ns5__union_ObjectType_ns1__QualifyingProperties	(1)
	ns1__QualifyingPropertiesType *ns1__QualifyingProperties;
#define SOAP_UNION__ns5__union_ObjectType_ns7__SVGList	(2)
	ns7__SVGListType *ns7__SVGList;
#define SOAP_UNION__ns5__union_ObjectType_ns3__Attribute	(3)
	ns3__AttributeType *ns3__Attribute;
};
#endif

/* SCAP-Services.h:291 */
#ifndef SOAP_TYPE_ns5__ObjectType
#define SOAP_TYPE_ns5__ObjectType (43)
/* ns5:ObjectType complex type: */
class SOAP_CMAC ns5__ObjectType
{
public:
	int __union_ObjectType;	/* union discriminant (of union defined below) */
	union _ns5__union_ObjectType union_ObjectType;
	std::string Id;	/* required attribute of XSD type xsd:ID */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns5__ObjectType (43)
	virtual int soap_type(void) const { return 43; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns5__ObjectType, default initialized and not managed by a soap context
	virtual ns5__ObjectType *soap_alloc(void) const { return SOAP_NEW(ns5__ObjectType); }
	         ns5__ObjectType() { ns5__ObjectType::soap_default(NULL); }
	virtual ~ns5__ObjectType() { }
	friend SOAP_FMAC1 ns5__ObjectType * SOAP_FMAC2 soap_instantiate_ns5__ObjectType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:303 */
#ifndef SOAP_TYPE_ns3__AttributeType
#define SOAP_TYPE_ns3__AttributeType (47)
/* ns3:AttributeType complex type: */
class SOAP_CMAC ns3__AttributeType
{
public:
	ns3__AttributeSupplierType *AttributeSupplier;	/* required element of XSD type ns3:AttributeSupplierType */
	std::string Date;	/* required element of XSD type ns4:DateType */
	std::string Validity;	/* required element of XSD type ns4:ValidityType */
	ns3__PersonalDataType *PersonalData;	/* required element of XSD type ns3:PersonalDataType */
	ns3__MainAttributeType *MainAttribute;	/* required element of XSD type ns3:MainAttributeType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns3__AttributeType (47)
	virtual int soap_type(void) const { return 47; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns3__AttributeType, default initialized and not managed by a soap context
	virtual ns3__AttributeType *soap_alloc(void) const { return SOAP_NEW(ns3__AttributeType); }
	         ns3__AttributeType() { ns3__AttributeType::soap_default(NULL); }
	virtual ~ns3__AttributeType() { }
	friend SOAP_FMAC1 ns3__AttributeType * SOAP_FMAC2 soap_instantiate_ns3__AttributeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:306 */
#ifndef SOAP_TYPE_ns3__AttributeSupplierType
#define SOAP_TYPE_ns3__AttributeSupplierType (48)
/* ns3:AttributeSupplierType complex type: */
class SOAP_CMAC ns3__AttributeSupplierType
{
public:
	std::string Id;	/* required element of XSD type xsd:anyURI */
	std::string Name;	/* required element of XSD type ns4:NameType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns3__AttributeSupplierType (48)
	virtual int soap_type(void) const { return 48; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns3__AttributeSupplierType, default initialized and not managed by a soap context
	virtual ns3__AttributeSupplierType *soap_alloc(void) const { return SOAP_NEW(ns3__AttributeSupplierType); }
	         ns3__AttributeSupplierType() { ns3__AttributeSupplierType::soap_default(NULL); }
	virtual ~ns3__AttributeSupplierType() { }
	friend SOAP_FMAC1 ns3__AttributeSupplierType * SOAP_FMAC2 soap_instantiate_ns3__AttributeSupplierType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:309 */
#ifndef SOAP_TYPE_ns3__PersonalDataType
#define SOAP_TYPE_ns3__PersonalDataType (49)
/* ns3:PersonalDataType complex type: */
class SOAP_CMAC ns3__PersonalDataType
{
public:
	std::string Name;	/* required element of XSD type ns4:NameType */
	std::string NIC;	/* required element of XSD type ns4:NICType */
	ns3__ExtraIDListType *ExtraIDList;	/* optional element of XSD type ns3:ExtraIDListType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns3__PersonalDataType (49)
	virtual int soap_type(void) const { return 49; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns3__PersonalDataType, default initialized and not managed by a soap context
	virtual ns3__PersonalDataType *soap_alloc(void) const { return SOAP_NEW(ns3__PersonalDataType); }
	         ns3__PersonalDataType() { ns3__PersonalDataType::soap_default(NULL); }
	virtual ~ns3__PersonalDataType() { }
	friend SOAP_FMAC1 ns3__PersonalDataType * SOAP_FMAC2 soap_instantiate_ns3__PersonalDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:312 */
#ifndef SOAP_TYPE_ns3__ExtraIDListType
#define SOAP_TYPE_ns3__ExtraIDListType (50)
/* ns3:ExtraIDListType complex type: */
class SOAP_CMAC ns3__ExtraIDListType
{
public:
	std::vector<ns3__ExtraIDType *> ExtraID;	/* required element of XSD type ns3:ExtraIDType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns3__ExtraIDListType (50)
	virtual int soap_type(void) const { return 50; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns3__ExtraIDListType, default initialized and not managed by a soap context
	virtual ns3__ExtraIDListType *soap_alloc(void) const { return SOAP_NEW(ns3__ExtraIDListType); }
	         ns3__ExtraIDListType() { ns3__ExtraIDListType::soap_default(NULL); }
	virtual ~ns3__ExtraIDListType() { }
	friend SOAP_FMAC1 ns3__ExtraIDListType * SOAP_FMAC2 soap_instantiate_ns3__ExtraIDListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:315 */
#ifndef SOAP_TYPE_ns3__ExtraIDType
#define SOAP_TYPE_ns3__ExtraIDType (51)
/* ns3:ExtraIDType complex type: */
class SOAP_CMAC ns3__ExtraIDType
{
public:
	std::string Name;	/* required element of XSD type ns4:NameType */
	std::string Value;	/* required element of XSD type ns4:ExtraIDValueType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns3__ExtraIDType (51)
	virtual int soap_type(void) const { return 51; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns3__ExtraIDType, default initialized and not managed by a soap context
	virtual ns3__ExtraIDType *soap_alloc(void) const { return SOAP_NEW(ns3__ExtraIDType); }
	         ns3__ExtraIDType() { ns3__ExtraIDType::soap_default(NULL); }
	virtual ~ns3__ExtraIDType() { }
	friend SOAP_FMAC1 ns3__ExtraIDType * SOAP_FMAC2 soap_instantiate_ns3__ExtraIDType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:318 */
#ifndef SOAP_TYPE_ns3__MainAttributeType
#define SOAP_TYPE_ns3__MainAttributeType (52)
/* ns3:MainAttributeType complex type: */
class SOAP_CMAC ns3__MainAttributeType
{
public:
	std::string AttributeID;	/* required element of XSD type ns4:AttributeIDType */
	std::string *Description;	/* optional element of XSD type ns4:DescriptionType */
	ns3__LegalActListType *LegalActList;	/* optional element of XSD type ns3:LegalActListType */
	ns3__SubAttributeListType *SubAttributeList;	/* optional element of XSD type ns3:SubAttributeListType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns3__MainAttributeType (52)
	virtual int soap_type(void) const { return 52; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns3__MainAttributeType, default initialized and not managed by a soap context
	virtual ns3__MainAttributeType *soap_alloc(void) const { return SOAP_NEW(ns3__MainAttributeType); }
	         ns3__MainAttributeType() { ns3__MainAttributeType::soap_default(NULL); }
	virtual ~ns3__MainAttributeType() { }
	friend SOAP_FMAC1 ns3__MainAttributeType * SOAP_FMAC2 soap_instantiate_ns3__MainAttributeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:321 */
#ifndef SOAP_TYPE_ns3__LegalActListType
#define SOAP_TYPE_ns3__LegalActListType (53)
/* ns3:LegalActListType complex type: */
class SOAP_CMAC ns3__LegalActListType
{
public:
	std::vector<std::string> LegalAct;	/* required element of XSD type ns4:LegalActType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns3__LegalActListType (53)
	virtual int soap_type(void) const { return 53; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns3__LegalActListType, default initialized and not managed by a soap context
	virtual ns3__LegalActListType *soap_alloc(void) const { return SOAP_NEW(ns3__LegalActListType); }
	         ns3__LegalActListType() { ns3__LegalActListType::soap_default(NULL); }
	virtual ~ns3__LegalActListType() { }
	friend SOAP_FMAC1 ns3__LegalActListType * SOAP_FMAC2 soap_instantiate_ns3__LegalActListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:324 */
#ifndef SOAP_TYPE_ns3__SubAttributeListType
#define SOAP_TYPE_ns3__SubAttributeListType (54)
/* ns3:SubAttributeListType complex type: */
class SOAP_CMAC ns3__SubAttributeListType
{
public:
	std::vector<ns3__SubAttributeType *> SubAttribute;	/* required element of XSD type ns3:SubAttributeType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns3__SubAttributeListType (54)
	virtual int soap_type(void) const { return 54; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns3__SubAttributeListType, default initialized and not managed by a soap context
	virtual ns3__SubAttributeListType *soap_alloc(void) const { return SOAP_NEW(ns3__SubAttributeListType); }
	         ns3__SubAttributeListType() { ns3__SubAttributeListType::soap_default(NULL); }
	virtual ~ns3__SubAttributeListType() { }
	friend SOAP_FMAC1 ns3__SubAttributeListType * SOAP_FMAC2 soap_instantiate_ns3__SubAttributeListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:327 */
#ifndef SOAP_TYPE_ns3__SubAttributeType
#define SOAP_TYPE_ns3__SubAttributeType (55)
/* ns3:SubAttributeType complex type: */
class SOAP_CMAC ns3__SubAttributeType
{
public:
	std::string AttributeID;	/* required element of XSD type ns4:AttributeIDType */
	std::string *Description;	/* optional element of XSD type ns4:DescriptionType */
	std::string *Value;	/* optional element of XSD type ns4:SubAttributeValueType */
	ns3__LegalActListType *LegalActList;	/* optional element of XSD type ns3:LegalActListType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns3__SubAttributeType (55)
	virtual int soap_type(void) const { return 55; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns3__SubAttributeType, default initialized and not managed by a soap context
	virtual ns3__SubAttributeType *soap_alloc(void) const { return SOAP_NEW(ns3__SubAttributeType); }
	         ns3__SubAttributeType() { ns3__SubAttributeType::soap_default(NULL); }
	virtual ~ns3__SubAttributeType() { }
	friend SOAP_FMAC1 ns3__SubAttributeType * SOAP_FMAC2 soap_instantiate_ns3__SubAttributeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:330 */
#ifndef SOAP_TYPE_ns3__ResponseCodeStatusType
#define SOAP_TYPE_ns3__ResponseCodeStatusType (56)
/* ns3:ResponseCodeStatusType complex type: */
class SOAP_CMAC ns3__ResponseCodeStatusType
{
public:
	std::string Code;	/* required element of XSD type ns4:ResponseCodeType */
	std::string *Message;	/* optional element of XSD type ns4:ResponseCodeMessage */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns3__ResponseCodeStatusType (56)
	virtual int soap_type(void) const { return 56; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns3__ResponseCodeStatusType, default initialized and not managed by a soap context
	virtual ns3__ResponseCodeStatusType *soap_alloc(void) const { return SOAP_NEW(ns3__ResponseCodeStatusType); }
	         ns3__ResponseCodeStatusType() { ns3__ResponseCodeStatusType::soap_default(NULL); }
	virtual ~ns3__ResponseCodeStatusType() { }
	friend SOAP_FMAC1 ns3__ResponseCodeStatusType * SOAP_FMAC2 soap_instantiate_ns3__ResponseCodeStatusType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:333 */
#ifndef SOAP_TYPE_ns1__QualifyingPropertiesType
#define SOAP_TYPE_ns1__QualifyingPropertiesType (57)
/* ns1:QualifyingPropertiesType complex type: */
class SOAP_CMAC ns1__QualifyingPropertiesType
{
public:
	ns1__SignedPropertiesType *ns1__SignedProperties;	/* required element of XSD type ns1:SignedPropertiesType */
	ns1__UnsignedPropertiesType *ns1__UnsignedProperties;	/* optional element of XSD type ns1:UnsignedPropertiesType */
	std::string Target;	/* required attribute of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__QualifyingPropertiesType (57)
	virtual int soap_type(void) const { return 57; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__QualifyingPropertiesType, default initialized and not managed by a soap context
	virtual ns1__QualifyingPropertiesType *soap_alloc(void) const { return SOAP_NEW(ns1__QualifyingPropertiesType); }
	         ns1__QualifyingPropertiesType() { ns1__QualifyingPropertiesType::soap_default(NULL); }
	virtual ~ns1__QualifyingPropertiesType() { }
	friend SOAP_FMAC1 ns1__QualifyingPropertiesType * SOAP_FMAC2 soap_instantiate_ns1__QualifyingPropertiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:336 */
#ifndef SOAP_TYPE_ns1__SignedPropertiesType
#define SOAP_TYPE_ns1__SignedPropertiesType (58)
/* ns1:SignedPropertiesType complex type: */
class SOAP_CMAC ns1__SignedPropertiesType
{
public:
	ns1__SignedSignaturePropertiesType *ns1__SignedSignatureProperties;	/* required element of XSD type ns1:SignedSignaturePropertiesType */
	std::string Id;	/* required attribute of XSD type xsd:ID */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__SignedPropertiesType (58)
	virtual int soap_type(void) const { return 58; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__SignedPropertiesType, default initialized and not managed by a soap context
	virtual ns1__SignedPropertiesType *soap_alloc(void) const { return SOAP_NEW(ns1__SignedPropertiesType); }
	         ns1__SignedPropertiesType() { ns1__SignedPropertiesType::soap_default(NULL); }
	virtual ~ns1__SignedPropertiesType() { }
	friend SOAP_FMAC1 ns1__SignedPropertiesType * SOAP_FMAC2 soap_instantiate_ns1__SignedPropertiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:339 */
#ifndef SOAP_TYPE_ns1__SignedSignaturePropertiesType
#define SOAP_TYPE_ns1__SignedSignaturePropertiesType (59)
/* ns1:SignedSignaturePropertiesType complex type: */
class SOAP_CMAC ns1__SignedSignaturePropertiesType
{
public:
	time_t ns1__SigningTime;	/* required element of XSD type ns1:SigningTimeType */
	ns1__SigningCertificateType *ns1__SigningCertificate;	/* required element of XSD type ns1:SigningCertificateType */
	ns1__SignerRoleType *ns1__SignerRole;	/* optional element of XSD type ns1:SignerRoleType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__SignedSignaturePropertiesType (59)
	virtual int soap_type(void) const { return 59; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__SignedSignaturePropertiesType, default initialized and not managed by a soap context
	virtual ns1__SignedSignaturePropertiesType *soap_alloc(void) const { return SOAP_NEW(ns1__SignedSignaturePropertiesType); }
	         ns1__SignedSignaturePropertiesType() { ns1__SignedSignaturePropertiesType::soap_default(NULL); }
	virtual ~ns1__SignedSignaturePropertiesType() { }
	friend SOAP_FMAC1 ns1__SignedSignaturePropertiesType * SOAP_FMAC2 soap_instantiate_ns1__SignedSignaturePropertiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:342 */
#ifndef SOAP_TYPE_ns1__SigningCertificateType
#define SOAP_TYPE_ns1__SigningCertificateType (60)
/* ns1:SigningCertificateType complex type: */
class SOAP_CMAC ns1__SigningCertificateType
{
public:
	ns1__CertType *ns1__Cert;	/* required element of XSD type ns1:CertType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__SigningCertificateType (60)
	virtual int soap_type(void) const { return 60; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__SigningCertificateType, default initialized and not managed by a soap context
	virtual ns1__SigningCertificateType *soap_alloc(void) const { return SOAP_NEW(ns1__SigningCertificateType); }
	         ns1__SigningCertificateType() { ns1__SigningCertificateType::soap_default(NULL); }
	virtual ~ns1__SigningCertificateType() { }
	friend SOAP_FMAC1 ns1__SigningCertificateType * SOAP_FMAC2 soap_instantiate_ns1__SigningCertificateType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:345 */
#ifndef SOAP_TYPE_ns1__CertType
#define SOAP_TYPE_ns1__CertType (61)
/* ns1:CertType complex type: */
class SOAP_CMAC ns1__CertType
{
public:
	ns1__CertDigestType *ns1__CertDigest;	/* required element of XSD type ns1:CertDigestType */
	ns1__IssuerSerialType *ns1__IssuerSerial;	/* required element of XSD type ns1:IssuerSerialType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__CertType (61)
	virtual int soap_type(void) const { return 61; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__CertType, default initialized and not managed by a soap context
	virtual ns1__CertType *soap_alloc(void) const { return SOAP_NEW(ns1__CertType); }
	         ns1__CertType() { ns1__CertType::soap_default(NULL); }
	virtual ~ns1__CertType() { }
	friend SOAP_FMAC1 ns1__CertType * SOAP_FMAC2 soap_instantiate_ns1__CertType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:348 */
#ifndef SOAP_TYPE_ns1__CertDigestType
#define SOAP_TYPE_ns1__CertDigestType (62)
/* ns1:CertDigestType complex type: */
class SOAP_CMAC ns1__CertDigestType
{
public:
	ns5__DigestMethodType *ns5__DigestMethod;	/* required element of XSD type ns5:DigestMethodType */
	ns5__DigestValueType *ns5__DigestValue;	/* required element of XSD type ns5:DigestValueType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__CertDigestType (62)
	virtual int soap_type(void) const { return 62; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__CertDigestType, default initialized and not managed by a soap context
	virtual ns1__CertDigestType *soap_alloc(void) const { return SOAP_NEW(ns1__CertDigestType); }
	         ns1__CertDigestType() { ns1__CertDigestType::soap_default(NULL); }
	virtual ~ns1__CertDigestType() { }
	friend SOAP_FMAC1 ns1__CertDigestType * SOAP_FMAC2 soap_instantiate_ns1__CertDigestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:351 */
#ifndef SOAP_TYPE_ns1__IssuerSerialType
#define SOAP_TYPE_ns1__IssuerSerialType (63)
/* ns1:IssuerSerialType complex type: */
class SOAP_CMAC ns1__IssuerSerialType
{
public:
	std::string ns5__X509IssuerName;	/* required element of XSD type ns5:X509IssuerNameType */
	std::string ns5__X509SerialNumber;	/* required element of XSD type ns5:X509SerialNumberType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__IssuerSerialType (63)
	virtual int soap_type(void) const { return 63; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__IssuerSerialType, default initialized and not managed by a soap context
	virtual ns1__IssuerSerialType *soap_alloc(void) const { return SOAP_NEW(ns1__IssuerSerialType); }
	         ns1__IssuerSerialType() { ns1__IssuerSerialType::soap_default(NULL); }
	virtual ~ns1__IssuerSerialType() { }
	friend SOAP_FMAC1 ns1__IssuerSerialType * SOAP_FMAC2 soap_instantiate_ns1__IssuerSerialType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:354 */
#ifndef SOAP_TYPE_ns1__SignerRoleType
#define SOAP_TYPE_ns1__SignerRoleType (64)
/* ns1:SignerRoleType complex type: */
class SOAP_CMAC ns1__SignerRoleType
{
public:
	ns1__ClaimedRolesListType *ns1__ClaimedRoles;	/* required element of XSD type ns1:ClaimedRolesListType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__SignerRoleType (64)
	virtual int soap_type(void) const { return 64; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__SignerRoleType, default initialized and not managed by a soap context
	virtual ns1__SignerRoleType *soap_alloc(void) const { return SOAP_NEW(ns1__SignerRoleType); }
	         ns1__SignerRoleType() { ns1__SignerRoleType::soap_default(NULL); }
	virtual ~ns1__SignerRoleType() { }
	friend SOAP_FMAC1 ns1__SignerRoleType * SOAP_FMAC2 soap_instantiate_ns1__SignerRoleType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:357 */
#ifndef SOAP_TYPE_ns1__ClaimedRolesListType
#define SOAP_TYPE_ns1__ClaimedRolesListType (65)
/* ns1:ClaimedRolesListType complex type: */
class SOAP_CMAC ns1__ClaimedRolesListType
{
public:
	std::vector<ns1__ClaimedRoleType *> ns1__ClaimedRole;	/* required element of XSD type ns1:ClaimedRoleType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__ClaimedRolesListType (65)
	virtual int soap_type(void) const { return 65; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__ClaimedRolesListType, default initialized and not managed by a soap context
	virtual ns1__ClaimedRolesListType *soap_alloc(void) const { return SOAP_NEW(ns1__ClaimedRolesListType); }
	         ns1__ClaimedRolesListType() { ns1__ClaimedRolesListType::soap_default(NULL); }
	virtual ~ns1__ClaimedRolesListType() { }
	friend SOAP_FMAC1 ns1__ClaimedRolesListType * SOAP_FMAC2 soap_instantiate_ns1__ClaimedRolesListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:360 */
#ifndef SOAP_TYPE_ns1__ClaimedRoleType
#define SOAP_TYPE_ns1__ClaimedRoleType (66)
/* ns1:ClaimedRoleType complex type: */
class SOAP_CMAC ns1__ClaimedRoleType
{
public:
	ns5__SignatureType *ns3__SignatureAttribute;	/* required element of XSD type ns5:SignatureType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__ClaimedRoleType (66)
	virtual int soap_type(void) const { return 66; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__ClaimedRoleType, default initialized and not managed by a soap context
	virtual ns1__ClaimedRoleType *soap_alloc(void) const { return SOAP_NEW(ns1__ClaimedRoleType); }
	         ns1__ClaimedRoleType() { ns1__ClaimedRoleType::soap_default(NULL); }
	virtual ~ns1__ClaimedRoleType() { }
	friend SOAP_FMAC1 ns1__ClaimedRoleType * SOAP_FMAC2 soap_instantiate_ns1__ClaimedRoleType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:363 */
#ifndef SOAP_TYPE_ns1__UnsignedPropertiesType
#define SOAP_TYPE_ns1__UnsignedPropertiesType (67)
/* ns1:UnsignedPropertiesType complex type: */
class SOAP_CMAC ns1__UnsignedPropertiesType
{
public:
	ns1__UnsignedSignaturePropertiesType *ns1__UnsignedSignatureProperties;	/* required element of XSD type ns1:UnsignedSignaturePropertiesType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__UnsignedPropertiesType (67)
	virtual int soap_type(void) const { return 67; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__UnsignedPropertiesType, default initialized and not managed by a soap context
	virtual ns1__UnsignedPropertiesType *soap_alloc(void) const { return SOAP_NEW(ns1__UnsignedPropertiesType); }
	         ns1__UnsignedPropertiesType() { ns1__UnsignedPropertiesType::soap_default(NULL); }
	virtual ~ns1__UnsignedPropertiesType() { }
	friend SOAP_FMAC1 ns1__UnsignedPropertiesType * SOAP_FMAC2 soap_instantiate_ns1__UnsignedPropertiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:366 */
#ifndef SOAP_TYPE_ns1__UnsignedSignaturePropertiesType
#define SOAP_TYPE_ns1__UnsignedSignaturePropertiesType (68)
/* ns1:UnsignedSignaturePropertiesType complex type: */
class SOAP_CMAC ns1__UnsignedSignaturePropertiesType
{
public:
	ns1__CounterSignatureType *ns1__CounterSignature;	/* optional element of XSD type ns1:CounterSignatureType */
	ns1__SignatureTimeStampType *ns1__SignatureTimeStamp;	/* required element of XSD type ns1:SignatureTimeStampType */
	ns1__CompleteCertificateRefsType *ns1__CompleteCertificateRefs;	/* required element of XSD type ns1:CompleteCertificateRefsType */
	ns1__CompleteRevocationRefsType *ns1__CompleteRevocationRefs;	/* required element of XSD type ns1:CompleteRevocationRefsType */
	ns1__SigAndRefsTimeStampType *ns1__SigAndRefsTimeStamp;	/* required element of XSD type ns1:SigAndRefsTimeStampType */
	ns1__CertificateValuesType *ns1__CertificateValues;	/* required element of XSD type ns1:CertificateValuesType */
	ns1__RevocationValuesType *ns1__RevocationValues;	/* required element of XSD type ns1:RevocationValuesType */
	ns1__ArchiveTimeStampType *ns1__ArchiveTimeStamp;	/* required element of XSD type ns1:ArchiveTimeStampType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__UnsignedSignaturePropertiesType (68)
	virtual int soap_type(void) const { return 68; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__UnsignedSignaturePropertiesType, default initialized and not managed by a soap context
	virtual ns1__UnsignedSignaturePropertiesType *soap_alloc(void) const { return SOAP_NEW(ns1__UnsignedSignaturePropertiesType); }
	         ns1__UnsignedSignaturePropertiesType() { ns1__UnsignedSignaturePropertiesType::soap_default(NULL); }
	virtual ~ns1__UnsignedSignaturePropertiesType() { }
	friend SOAP_FMAC1 ns1__UnsignedSignaturePropertiesType * SOAP_FMAC2 soap_instantiate_ns1__UnsignedSignaturePropertiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:369 */
#ifndef SOAP_TYPE_ns1__CounterSignatureType
#define SOAP_TYPE_ns1__CounterSignatureType (69)
/* ns1:CounterSignatureType complex type: */
class SOAP_CMAC ns1__CounterSignatureType
{
public:
	ns5__SignatureType *ns5__Signature;	/* required element of XSD type ns5:SignatureType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__CounterSignatureType (69)
	virtual int soap_type(void) const { return 69; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__CounterSignatureType, default initialized and not managed by a soap context
	virtual ns1__CounterSignatureType *soap_alloc(void) const { return SOAP_NEW(ns1__CounterSignatureType); }
	         ns1__CounterSignatureType() { ns1__CounterSignatureType::soap_default(NULL); }
	virtual ~ns1__CounterSignatureType() { }
	friend SOAP_FMAC1 ns1__CounterSignatureType * SOAP_FMAC2 soap_instantiate_ns1__CounterSignatureType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:372 */
#ifndef SOAP_TYPE_ns1__SignatureTimeStampType
#define SOAP_TYPE_ns1__SignatureTimeStampType (70)
/* ns1:SignatureTimeStampType complex type: */
class SOAP_CMAC ns1__SignatureTimeStampType
{
public:
	ns5__CanonicalizationMethodType *ns5__CanonicalizationMethod;	/* required element of XSD type ns5:CanonicalizationMethodType */
	xsd__base64Binary ns1__EncapsulatedTimeStamp;	/* required element of XSD type ns1:EncapsulatedTimeStampType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__SignatureTimeStampType (70)
	virtual int soap_type(void) const { return 70; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__SignatureTimeStampType, default initialized and not managed by a soap context
	virtual ns1__SignatureTimeStampType *soap_alloc(void) const { return SOAP_NEW(ns1__SignatureTimeStampType); }
	         ns1__SignatureTimeStampType() { ns1__SignatureTimeStampType::soap_default(NULL); }
	virtual ~ns1__SignatureTimeStampType() { }
	friend SOAP_FMAC1 ns1__SignatureTimeStampType * SOAP_FMAC2 soap_instantiate_ns1__SignatureTimeStampType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:375 */
#ifndef SOAP_TYPE_ns1__CompleteCertificateRefsType
#define SOAP_TYPE_ns1__CompleteCertificateRefsType (71)
/* ns1:CompleteCertificateRefsType complex type: */
class SOAP_CMAC ns1__CompleteCertificateRefsType
{
public:
	ns1__CertRefsType *ns1__CertRefs;	/* required element of XSD type ns1:CertRefsType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__CompleteCertificateRefsType (71)
	virtual int soap_type(void) const { return 71; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__CompleteCertificateRefsType, default initialized and not managed by a soap context
	virtual ns1__CompleteCertificateRefsType *soap_alloc(void) const { return SOAP_NEW(ns1__CompleteCertificateRefsType); }
	         ns1__CompleteCertificateRefsType() { ns1__CompleteCertificateRefsType::soap_default(NULL); }
	virtual ~ns1__CompleteCertificateRefsType() { }
	friend SOAP_FMAC1 ns1__CompleteCertificateRefsType * SOAP_FMAC2 soap_instantiate_ns1__CompleteCertificateRefsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:378 */
#ifndef SOAP_TYPE_ns1__CertRefsType
#define SOAP_TYPE_ns1__CertRefsType (72)
/* ns1:CertRefsType complex type: */
class SOAP_CMAC ns1__CertRefsType
{
public:
	std::vector<ns1__CertType *> ns1__Cert;	/* required element of XSD type ns1:CertType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__CertRefsType (72)
	virtual int soap_type(void) const { return 72; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__CertRefsType, default initialized and not managed by a soap context
	virtual ns1__CertRefsType *soap_alloc(void) const { return SOAP_NEW(ns1__CertRefsType); }
	         ns1__CertRefsType() { ns1__CertRefsType::soap_default(NULL); }
	virtual ~ns1__CertRefsType() { }
	friend SOAP_FMAC1 ns1__CertRefsType * SOAP_FMAC2 soap_instantiate_ns1__CertRefsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:381 */
#ifndef SOAP_TYPE_ns1__CompleteRevocationRefsType
#define SOAP_TYPE_ns1__CompleteRevocationRefsType (73)
/* ns1:CompleteRevocationRefsType complex type: */
class SOAP_CMAC ns1__CompleteRevocationRefsType
{
public:
	ns1__CRLRefsType *ns1__CRLRefs;	/* required element of XSD type ns1:CRLRefsType */
	ns1__OCSPRefsType *ns1__OCSPRefs;	/* required element of XSD type ns1:OCSPRefsType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__CompleteRevocationRefsType (73)
	virtual int soap_type(void) const { return 73; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__CompleteRevocationRefsType, default initialized and not managed by a soap context
	virtual ns1__CompleteRevocationRefsType *soap_alloc(void) const { return SOAP_NEW(ns1__CompleteRevocationRefsType); }
	         ns1__CompleteRevocationRefsType() { ns1__CompleteRevocationRefsType::soap_default(NULL); }
	virtual ~ns1__CompleteRevocationRefsType() { }
	friend SOAP_FMAC1 ns1__CompleteRevocationRefsType * SOAP_FMAC2 soap_instantiate_ns1__CompleteRevocationRefsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:384 */
#ifndef SOAP_TYPE_ns1__CRLRefsType
#define SOAP_TYPE_ns1__CRLRefsType (74)
/* ns1:CRLRefsType complex type: */
class SOAP_CMAC ns1__CRLRefsType
{
public:
	std::vector<ns1__CRLRefType *> ns1__CRLRef;	/* required element of XSD type ns1:CRLRefType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__CRLRefsType (74)
	virtual int soap_type(void) const { return 74; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__CRLRefsType, default initialized and not managed by a soap context
	virtual ns1__CRLRefsType *soap_alloc(void) const { return SOAP_NEW(ns1__CRLRefsType); }
	         ns1__CRLRefsType() { ns1__CRLRefsType::soap_default(NULL); }
	virtual ~ns1__CRLRefsType() { }
	friend SOAP_FMAC1 ns1__CRLRefsType * SOAP_FMAC2 soap_instantiate_ns1__CRLRefsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:387 */
#ifndef SOAP_TYPE_ns1__CRLRefType
#define SOAP_TYPE_ns1__CRLRefType (75)
/* ns1:CRLRefType complex type: */
class SOAP_CMAC ns1__CRLRefType
{
public:
	ns1__DigestAlgAndValueType *ns1__DigestAlgAndValue;	/* required element of XSD type ns1:DigestAlgAndValueType */
	ns1__CRLIdentifierType *ns1__CRLIdentifier;	/* required element of XSD type ns1:CRLIdentifierType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__CRLRefType (75)
	virtual int soap_type(void) const { return 75; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__CRLRefType, default initialized and not managed by a soap context
	virtual ns1__CRLRefType *soap_alloc(void) const { return SOAP_NEW(ns1__CRLRefType); }
	         ns1__CRLRefType() { ns1__CRLRefType::soap_default(NULL); }
	virtual ~ns1__CRLRefType() { }
	friend SOAP_FMAC1 ns1__CRLRefType * SOAP_FMAC2 soap_instantiate_ns1__CRLRefType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:390 */
#ifndef SOAP_TYPE_ns1__DigestAlgAndValueType
#define SOAP_TYPE_ns1__DigestAlgAndValueType (76)
/* ns1:DigestAlgAndValueType complex type: */
class SOAP_CMAC ns1__DigestAlgAndValueType
{
public:
	ns5__DigestMethodType *ns5__DigestMethod;	/* required element of XSD type ns5:DigestMethodType */
	ns5__DigestValueType *ns5__DigestValue;	/* required element of XSD type ns5:DigestValueType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__DigestAlgAndValueType (76)
	virtual int soap_type(void) const { return 76; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__DigestAlgAndValueType, default initialized and not managed by a soap context
	virtual ns1__DigestAlgAndValueType *soap_alloc(void) const { return SOAP_NEW(ns1__DigestAlgAndValueType); }
	         ns1__DigestAlgAndValueType() { ns1__DigestAlgAndValueType::soap_default(NULL); }
	virtual ~ns1__DigestAlgAndValueType() { }
	friend SOAP_FMAC1 ns1__DigestAlgAndValueType * SOAP_FMAC2 soap_instantiate_ns1__DigestAlgAndValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:393 */
#ifndef SOAP_TYPE_ns1__CRLIdentifierType
#define SOAP_TYPE_ns1__CRLIdentifierType (77)
/* ns1:CRLIdentifierType complex type: */
class SOAP_CMAC ns1__CRLIdentifierType
{
public:
	char *ns1__Issuer;	/* required element of XSD type xsd:anyType */
	char *ns1__IssueTime;	/* required element of XSD type xsd:anyType */
	char *ns1__Number;	/* required element of XSD type xsd:anyType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__CRLIdentifierType (77)
	virtual int soap_type(void) const { return 77; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__CRLIdentifierType, default initialized and not managed by a soap context
	virtual ns1__CRLIdentifierType *soap_alloc(void) const { return SOAP_NEW(ns1__CRLIdentifierType); }
	         ns1__CRLIdentifierType() { ns1__CRLIdentifierType::soap_default(NULL); }
	virtual ~ns1__CRLIdentifierType() { }
	friend SOAP_FMAC1 ns1__CRLIdentifierType * SOAP_FMAC2 soap_instantiate_ns1__CRLIdentifierType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:396 */
#ifndef SOAP_TYPE_ns1__OCSPRefsType
#define SOAP_TYPE_ns1__OCSPRefsType (78)
/* ns1:OCSPRefsType complex type: */
class SOAP_CMAC ns1__OCSPRefsType
{
public:
	std::vector<ns1__OCSPRefType *> ns1__OCSPRef;	/* required element of XSD type ns1:OCSPRefType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__OCSPRefsType (78)
	virtual int soap_type(void) const { return 78; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__OCSPRefsType, default initialized and not managed by a soap context
	virtual ns1__OCSPRefsType *soap_alloc(void) const { return SOAP_NEW(ns1__OCSPRefsType); }
	         ns1__OCSPRefsType() { ns1__OCSPRefsType::soap_default(NULL); }
	virtual ~ns1__OCSPRefsType() { }
	friend SOAP_FMAC1 ns1__OCSPRefsType * SOAP_FMAC2 soap_instantiate_ns1__OCSPRefsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:399 */
#ifndef SOAP_TYPE_ns1__OCSPRefType
#define SOAP_TYPE_ns1__OCSPRefType (79)
/* ns1:OCSPRefType complex type: */
class SOAP_CMAC ns1__OCSPRefType
{
public:
	ns1__OCSPIdentifierType *ns1__OCSPIdentifier;	/* required element of XSD type ns1:OCSPIdentifierType */
	ns1__DigestAlgAndValueType *ns1__DigestAlgAndValue;	/* required element of XSD type ns1:DigestAlgAndValueType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__OCSPRefType (79)
	virtual int soap_type(void) const { return 79; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__OCSPRefType, default initialized and not managed by a soap context
	virtual ns1__OCSPRefType *soap_alloc(void) const { return SOAP_NEW(ns1__OCSPRefType); }
	         ns1__OCSPRefType() { ns1__OCSPRefType::soap_default(NULL); }
	virtual ~ns1__OCSPRefType() { }
	friend SOAP_FMAC1 ns1__OCSPRefType * SOAP_FMAC2 soap_instantiate_ns1__OCSPRefType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:402 */
#ifndef SOAP_TYPE_ns1__OCSPIdentifierType
#define SOAP_TYPE_ns1__OCSPIdentifierType (80)
/* ns1:OCSPIdentifierType complex type: */
class SOAP_CMAC ns1__OCSPIdentifierType
{
public:
	ns1__ResponderIDType *ns1__ResponderID;	/* required element of XSD type ns1:ResponderIDType */
	char *ns1__ProducedAt;	/* required element of XSD type xsd:anyType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__OCSPIdentifierType (80)
	virtual int soap_type(void) const { return 80; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__OCSPIdentifierType, default initialized and not managed by a soap context
	virtual ns1__OCSPIdentifierType *soap_alloc(void) const { return SOAP_NEW(ns1__OCSPIdentifierType); }
	         ns1__OCSPIdentifierType() { ns1__OCSPIdentifierType::soap_default(NULL); }
	virtual ~ns1__OCSPIdentifierType() { }
	friend SOAP_FMAC1 ns1__OCSPIdentifierType * SOAP_FMAC2 soap_instantiate_ns1__OCSPIdentifierType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:405 */
#ifndef SOAP_TYPE_ns1__ResponderIDType
#define SOAP_TYPE_ns1__ResponderIDType (81)
/* ns1:ResponderIDType complex type: */
class SOAP_CMAC ns1__ResponderIDType
{
public:
	char *ns1__ByName;	/* required element of XSD type xsd:anyType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__ResponderIDType (81)
	virtual int soap_type(void) const { return 81; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__ResponderIDType, default initialized and not managed by a soap context
	virtual ns1__ResponderIDType *soap_alloc(void) const { return SOAP_NEW(ns1__ResponderIDType); }
	         ns1__ResponderIDType() { ns1__ResponderIDType::soap_default(NULL); }
	virtual ~ns1__ResponderIDType() { }
	friend SOAP_FMAC1 ns1__ResponderIDType * SOAP_FMAC2 soap_instantiate_ns1__ResponderIDType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:408 */
#ifndef SOAP_TYPE_ns1__SigAndRefsTimeStampType
#define SOAP_TYPE_ns1__SigAndRefsTimeStampType (82)
/* ns1:SigAndRefsTimeStampType complex type: */
class SOAP_CMAC ns1__SigAndRefsTimeStampType
{
public:
	ns5__CanonicalizationMethodType *ns5__CanonicalizationMethod;	/* required element of XSD type ns5:CanonicalizationMethodType */
	xsd__base64Binary ns1__EncapsulatedTimeStamp;	/* required element of XSD type ns1:EncapsulatedTimeStampType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__SigAndRefsTimeStampType (82)
	virtual int soap_type(void) const { return 82; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__SigAndRefsTimeStampType, default initialized and not managed by a soap context
	virtual ns1__SigAndRefsTimeStampType *soap_alloc(void) const { return SOAP_NEW(ns1__SigAndRefsTimeStampType); }
	         ns1__SigAndRefsTimeStampType() { ns1__SigAndRefsTimeStampType::soap_default(NULL); }
	virtual ~ns1__SigAndRefsTimeStampType() { }
	friend SOAP_FMAC1 ns1__SigAndRefsTimeStampType * SOAP_FMAC2 soap_instantiate_ns1__SigAndRefsTimeStampType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:411 */
#ifndef SOAP_TYPE_ns1__CertificateValuesType
#define SOAP_TYPE_ns1__CertificateValuesType (83)
/* ns1:CertificateValuesType complex type: */
class SOAP_CMAC ns1__CertificateValuesType
{
public:
	std::vector<ns1__EncapsulatedX509CertificateType *> ns1__EncapsulatedX509Certificate;	/* required element of XSD type ns1:EncapsulatedX509CertificateType */
	std::string Id;	/* required attribute of XSD type xsd:ID */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__CertificateValuesType (83)
	virtual int soap_type(void) const { return 83; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__CertificateValuesType, default initialized and not managed by a soap context
	virtual ns1__CertificateValuesType *soap_alloc(void) const { return SOAP_NEW(ns1__CertificateValuesType); }
	         ns1__CertificateValuesType() { ns1__CertificateValuesType::soap_default(NULL); }
	virtual ~ns1__CertificateValuesType() { }
	friend SOAP_FMAC1 ns1__CertificateValuesType * SOAP_FMAC2 soap_instantiate_ns1__CertificateValuesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:417 */
#ifndef SOAP_TYPE_ns1__RevocationValuesType
#define SOAP_TYPE_ns1__RevocationValuesType (85)
/* ns1:RevocationValuesType complex type: */
class SOAP_CMAC ns1__RevocationValuesType
{
public:
	ns1__CRLValuesType *ns1__CRLValues;	/* required element of XSD type ns1:CRLValuesType */
	ns1__OCSPValuesType *ns1__OCSPValues;	/* required element of XSD type ns1:OCSPValuesType */
	std::string Id;	/* required attribute of XSD type xsd:ID */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__RevocationValuesType (85)
	virtual int soap_type(void) const { return 85; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__RevocationValuesType, default initialized and not managed by a soap context
	virtual ns1__RevocationValuesType *soap_alloc(void) const { return SOAP_NEW(ns1__RevocationValuesType); }
	         ns1__RevocationValuesType() { ns1__RevocationValuesType::soap_default(NULL); }
	virtual ~ns1__RevocationValuesType() { }
	friend SOAP_FMAC1 ns1__RevocationValuesType * SOAP_FMAC2 soap_instantiate_ns1__RevocationValuesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:420 */
#ifndef SOAP_TYPE_ns1__CRLValuesType
#define SOAP_TYPE_ns1__CRLValuesType (86)
/* ns1:CRLValuesType complex type: */
class SOAP_CMAC ns1__CRLValuesType
{
public:
	std::vector<ns1__EncapsulatedCRLValueType *> ns1__EncapsulatedCRLValue;	/* required element of XSD type ns1:EncapsulatedCRLValueType */
	std::string Id;	/* required attribute of XSD type xsd:ID */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__CRLValuesType (86)
	virtual int soap_type(void) const { return 86; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__CRLValuesType, default initialized and not managed by a soap context
	virtual ns1__CRLValuesType *soap_alloc(void) const { return SOAP_NEW(ns1__CRLValuesType); }
	         ns1__CRLValuesType() { ns1__CRLValuesType::soap_default(NULL); }
	virtual ~ns1__CRLValuesType() { }
	friend SOAP_FMAC1 ns1__CRLValuesType * SOAP_FMAC2 soap_instantiate_ns1__CRLValuesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:426 */
#ifndef SOAP_TYPE_ns1__OCSPValuesType
#define SOAP_TYPE_ns1__OCSPValuesType (88)
/* ns1:OCSPValuesType complex type: */
class SOAP_CMAC ns1__OCSPValuesType
{
public:
	std::vector<ns1__EncapsulatedOCSPValueType *> ns1__EncapsulatedOCSPValue;	/* required element of XSD type ns1:EncapsulatedOCSPValueType */
	std::string Id;	/* required attribute of XSD type xsd:ID */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__OCSPValuesType (88)
	virtual int soap_type(void) const { return 88; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__OCSPValuesType, default initialized and not managed by a soap context
	virtual ns1__OCSPValuesType *soap_alloc(void) const { return SOAP_NEW(ns1__OCSPValuesType); }
	         ns1__OCSPValuesType() { ns1__OCSPValuesType::soap_default(NULL); }
	virtual ~ns1__OCSPValuesType() { }
	friend SOAP_FMAC1 ns1__OCSPValuesType * SOAP_FMAC2 soap_instantiate_ns1__OCSPValuesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:432 */
#ifndef SOAP_TYPE_ns1__ArchiveTimeStampType
#define SOAP_TYPE_ns1__ArchiveTimeStampType (90)
/* ns1:ArchiveTimeStampType complex type: */
class SOAP_CMAC ns1__ArchiveTimeStampType
{
public:
	ns5__CanonicalizationMethodType *ns5__CanonicalizationMethod;	/* required element of XSD type ns5:CanonicalizationMethodType */
	xsd__base64Binary ns1__EncapsulatedTimeStamp;	/* required element of XSD type ns1:EncapsulatedTimeStampType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__ArchiveTimeStampType (90)
	virtual int soap_type(void) const { return 90; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__ArchiveTimeStampType, default initialized and not managed by a soap context
	virtual ns1__ArchiveTimeStampType *soap_alloc(void) const { return SOAP_NEW(ns1__ArchiveTimeStampType); }
	         ns1__ArchiveTimeStampType() { ns1__ArchiveTimeStampType::soap_default(NULL); }
	virtual ~ns1__ArchiveTimeStampType() { }
	friend SOAP_FMAC1 ns1__ArchiveTimeStampType * SOAP_FMAC2 soap_instantiate_ns1__ArchiveTimeStampType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:450 */
#ifndef SOAP_TYPE_ns7__SVGListType
#define SOAP_TYPE_ns7__SVGListType (96)
/* ns7:SVGListType complex type: */
class SOAP_CMAC ns7__SVGListType
{
public:
	std::vector<xsd__base64Binary> ns7__SVG;	/* required element of XSD type ns7:SVGType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns7__SVGListType (96)
	virtual int soap_type(void) const { return 96; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns7__SVGListType, default initialized and not managed by a soap context
	virtual ns7__SVGListType *soap_alloc(void) const { return SOAP_NEW(ns7__SVGListType); }
	         ns7__SVGListType() { ns7__SVGListType::soap_default(NULL); }
	virtual ~ns7__SVGListType() { }
	friend SOAP_FMAC1 ns7__SVGListType * SOAP_FMAC2 soap_instantiate_ns7__SVGListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:453 */
#ifndef SOAP_TYPE_ns3__AttributeSupplierResponseType
#define SOAP_TYPE_ns3__AttributeSupplierResponseType (97)
/* ns3:AttributeSupplierResponseType complex type: */
class SOAP_CMAC ns3__AttributeSupplierResponseType
{
public:
	std::vector<ns3__AttributeSupplierType *> AttributeSupplier;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns3:AttributeSupplierType */
	std::string *ErrorMessage;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns3__AttributeSupplierResponseType (97)
	virtual int soap_type(void) const { return 97; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns3__AttributeSupplierResponseType, default initialized and not managed by a soap context
	virtual ns3__AttributeSupplierResponseType *soap_alloc(void) const { return SOAP_NEW(ns3__AttributeSupplierResponseType); }
	         ns3__AttributeSupplierResponseType() { ns3__AttributeSupplierResponseType::soap_default(NULL); }
	virtual ~ns3__AttributeSupplierResponseType() { }
	friend SOAP_FMAC1 ns3__AttributeSupplierResponseType * SOAP_FMAC2 soap_instantiate_ns3__AttributeSupplierResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:456 */
#ifndef SOAP_TYPE_ns4__SignRequest
#define SOAP_TYPE_ns4__SignRequest (98)
/* ns4:SignRequest complex type: */
class SOAP_CMAC ns4__SignRequest
{
public:
	std::string ProcessId;	/* required element of XSD type xsd:string */
	ns4__PersonalDataType *PersonalData;	/* required element of XSD type ns4:PersonalDataType */
	ns4__AttributeListType *AttributeList;	/* required element of XSD type ns4:AttributeListType */
	std::string SignatureFieldName;	/* required element of XSD type xsd:string */
	xsd__base64Binary SignDocument;	/* required element of XSD type xsd:base64Binary */
	int *LTV;	/* optional element of XSD type xsd:int */
	int Page;	/* required element of XSD type xsd:int */
	int X;	/* required element of XSD type xsd:int */
	int Y;	/* required element of XSD type xsd:int */
	enum ns4__SignatureOrientationEnumType Orientation;	/* required element of XSD type ns4:SignatureOrientationEnumType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns4__SignRequest (98)
	virtual int soap_type(void) const { return 98; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns4__SignRequest, default initialized and not managed by a soap context
	virtual ns4__SignRequest *soap_alloc(void) const { return SOAP_NEW(ns4__SignRequest); }
	         ns4__SignRequest() { ns4__SignRequest::soap_default(NULL); }
	virtual ~ns4__SignRequest() { }
	friend SOAP_FMAC1 ns4__SignRequest * SOAP_FMAC2 soap_instantiate_ns4__SignRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:459 */
#ifndef SOAP_TYPE_ns4__PersonalDataType
#define SOAP_TYPE_ns4__PersonalDataType (99)
/* ns4:PersonalDataType complex type: */
class SOAP_CMAC ns4__PersonalDataType
{
public:
	std::string Name;	/* required element of XSD type xsd:string */
	std::string NIC;	/* required element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns4__PersonalDataType (99)
	virtual int soap_type(void) const { return 99; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns4__PersonalDataType, default initialized and not managed by a soap context
	virtual ns4__PersonalDataType *soap_alloc(void) const { return SOAP_NEW(ns4__PersonalDataType); }
	         ns4__PersonalDataType() { ns4__PersonalDataType::soap_default(NULL); }
	virtual ~ns4__PersonalDataType() { }
	friend SOAP_FMAC1 ns4__PersonalDataType * SOAP_FMAC2 soap_instantiate_ns4__PersonalDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:462 */
#ifndef SOAP_TYPE_ns4__AttributeListType
#define SOAP_TYPE_ns4__AttributeListType (100)
/* ns4:AttributeListType complex type: */
class SOAP_CMAC ns4__AttributeListType
{
public:
	std::vector<ns4__AttributeType *> Attribute;	/* required element of XSD type ns4:AttributeType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns4__AttributeListType (100)
	virtual int soap_type(void) const { return 100; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns4__AttributeListType, default initialized and not managed by a soap context
	virtual ns4__AttributeListType *soap_alloc(void) const { return SOAP_NEW(ns4__AttributeListType); }
	         ns4__AttributeListType() { ns4__AttributeListType::soap_default(NULL); }
	virtual ~ns4__AttributeListType() { }
	friend SOAP_FMAC1 ns4__AttributeListType * SOAP_FMAC2 soap_instantiate_ns4__AttributeListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:465 */
#ifndef SOAP_TYPE_ns4__AttributeType
#define SOAP_TYPE_ns4__AttributeType (101)
/* ns4:AttributeType complex type: */
class SOAP_CMAC ns4__AttributeType
{
public:
	ns4__AttributeSupplierType *AttributeSupplier;	/* required element of XSD type ns4:AttributeSupplierType */
	ns4__MainAttributeType *MainAttribute;	/* required element of XSD type ns4:MainAttributeType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns4__AttributeType (101)
	virtual int soap_type(void) const { return 101; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns4__AttributeType, default initialized and not managed by a soap context
	virtual ns4__AttributeType *soap_alloc(void) const { return SOAP_NEW(ns4__AttributeType); }
	         ns4__AttributeType() { ns4__AttributeType::soap_default(NULL); }
	virtual ~ns4__AttributeType() { }
	friend SOAP_FMAC1 ns4__AttributeType * SOAP_FMAC2 soap_instantiate_ns4__AttributeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:468 */
#ifndef SOAP_TYPE_ns4__AttributeSupplierType
#define SOAP_TYPE_ns4__AttributeSupplierType (102)
/* ns4:AttributeSupplierType complex type: */
class SOAP_CMAC ns4__AttributeSupplierType
{
public:
	std::string Id;	/* required element of XSD type xsd:anyURI */
	std::string Name;	/* required element of XSD type xsd:string */
	std::string *Type;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns4__AttributeSupplierType (102)
	virtual int soap_type(void) const { return 102; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns4__AttributeSupplierType, default initialized and not managed by a soap context
	virtual ns4__AttributeSupplierType *soap_alloc(void) const { return SOAP_NEW(ns4__AttributeSupplierType); }
	         ns4__AttributeSupplierType() { ns4__AttributeSupplierType::soap_default(NULL); }
	virtual ~ns4__AttributeSupplierType() { }
	friend SOAP_FMAC1 ns4__AttributeSupplierType * SOAP_FMAC2 soap_instantiate_ns4__AttributeSupplierType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:471 */
#ifndef SOAP_TYPE_ns4__MainAttributeType
#define SOAP_TYPE_ns4__MainAttributeType (103)
/* ns4:MainAttributeType complex type: */
class SOAP_CMAC ns4__MainAttributeType
{
public:
	std::string AttributeID;	/* required element of XSD type xsd:string */
	std::string *Description;	/* optional element of XSD type xsd:string */
	ns4__LegalActListType *LegalActList;	/* optional element of XSD type ns4:LegalActListType */
	ns4__SubAttributeListType *SubAttributeList;	/* optional element of XSD type ns4:SubAttributeListType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns4__MainAttributeType (103)
	virtual int soap_type(void) const { return 103; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns4__MainAttributeType, default initialized and not managed by a soap context
	virtual ns4__MainAttributeType *soap_alloc(void) const { return SOAP_NEW(ns4__MainAttributeType); }
	         ns4__MainAttributeType() { ns4__MainAttributeType::soap_default(NULL); }
	virtual ~ns4__MainAttributeType() { }
	friend SOAP_FMAC1 ns4__MainAttributeType * SOAP_FMAC2 soap_instantiate_ns4__MainAttributeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:474 */
#ifndef SOAP_TYPE_ns4__LegalActListType
#define SOAP_TYPE_ns4__LegalActListType (104)
/* ns4:LegalActListType complex type: */
class SOAP_CMAC ns4__LegalActListType
{
public:
	std::vector<std::string> LegalAct;	/* required element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns4__LegalActListType (104)
	virtual int soap_type(void) const { return 104; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns4__LegalActListType, default initialized and not managed by a soap context
	virtual ns4__LegalActListType *soap_alloc(void) const { return SOAP_NEW(ns4__LegalActListType); }
	         ns4__LegalActListType() { ns4__LegalActListType::soap_default(NULL); }
	virtual ~ns4__LegalActListType() { }
	friend SOAP_FMAC1 ns4__LegalActListType * SOAP_FMAC2 soap_instantiate_ns4__LegalActListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:477 */
#ifndef SOAP_TYPE_ns4__SubAttributeListType
#define SOAP_TYPE_ns4__SubAttributeListType (105)
/* ns4:SubAttributeListType complex type: */
class SOAP_CMAC ns4__SubAttributeListType
{
public:
	std::vector<ns4__SubAttributeType *> SubAttribute;	/* required element of XSD type ns4:SubAttributeType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns4__SubAttributeListType (105)
	virtual int soap_type(void) const { return 105; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns4__SubAttributeListType, default initialized and not managed by a soap context
	virtual ns4__SubAttributeListType *soap_alloc(void) const { return SOAP_NEW(ns4__SubAttributeListType); }
	         ns4__SubAttributeListType() { ns4__SubAttributeListType::soap_default(NULL); }
	virtual ~ns4__SubAttributeListType() { }
	friend SOAP_FMAC1 ns4__SubAttributeListType * SOAP_FMAC2 soap_instantiate_ns4__SubAttributeListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:480 */
#ifndef SOAP_TYPE_ns4__SubAttributeType
#define SOAP_TYPE_ns4__SubAttributeType (106)
/* ns4:SubAttributeType complex type: */
class SOAP_CMAC ns4__SubAttributeType
{
public:
	std::string AttributeID;	/* required element of XSD type xsd:string */
	std::string *Description;	/* optional element of XSD type xsd:string */
	std::string *Value;	/* optional element of XSD type xsd:string */
	ns4__LegalActListType *LegalActList;	/* optional element of XSD type ns4:LegalActListType */
	std::string *Type;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns4__SubAttributeType (106)
	virtual int soap_type(void) const { return 106; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns4__SubAttributeType, default initialized and not managed by a soap context
	virtual ns4__SubAttributeType *soap_alloc(void) const { return SOAP_NEW(ns4__SubAttributeType); }
	         ns4__SubAttributeType() { ns4__SubAttributeType::soap_default(NULL); }
	virtual ~ns4__SubAttributeType() { }
	friend SOAP_FMAC1 ns4__SubAttributeType * SOAP_FMAC2 soap_instantiate_ns4__SubAttributeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:483 */
#ifndef SOAP_TYPE_ns4__SignResponse
#define SOAP_TYPE_ns4__SignResponse (107)
/* ns4:SignResponse complex type: */
class SOAP_CMAC ns4__SignResponse
{
public:
	std::string ProcessId;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:string */
	ns4__Status *Status;	/* required element of XSD type ns4:Status */
	xsd__base64Binary *SignedDocument;	/* optional element of XSD type xsd:base64Binary */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns4__SignResponse (107)
	virtual int soap_type(void) const { return 107; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns4__SignResponse, default initialized and not managed by a soap context
	virtual ns4__SignResponse *soap_alloc(void) const { return SOAP_NEW(ns4__SignResponse); }
	         ns4__SignResponse() { ns4__SignResponse::soap_default(NULL); }
	virtual ~ns4__SignResponse() { }
	friend SOAP_FMAC1 ns4__SignResponse * SOAP_FMAC2 soap_instantiate_ns4__SignResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:486 */
#ifndef SOAP_TYPE_ns4__Status
#define SOAP_TYPE_ns4__Status (108)
/* ns4:Status complex type: */
class SOAP_CMAC ns4__Status
{
public:
	std::string Code;	/* required element of XSD type xsd:string */
	std::string Message;	/* required element of XSD type xsd:string */
	std::string *Field;	/* optional element of XSD type xsd:string */
	std::string *FieldValue;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns4__Status (108)
	virtual int soap_type(void) const { return 108; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns4__Status, default initialized and not managed by a soap context
	virtual ns4__Status *soap_alloc(void) const { return SOAP_NEW(ns4__Status); }
	         ns4__Status() { ns4__Status::soap_default(NULL); }
	virtual ~ns4__Status() { }
	friend SOAP_FMAC1 ns4__Status * SOAP_FMAC2 soap_instantiate_ns4__Status(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:294 */
#ifndef SOAP_TYPE_ns5__X509CertificateType
#define SOAP_TYPE_ns5__X509CertificateType (44)
/* ns5:X509CertificateType simple type: */
class SOAP_CMAC ns5__X509CertificateType
{
public:
	xsd__base64Binary __item;	/* mixed XML content */
	std::string Id;	/* required attribute of XSD type xsd:ID */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns5__X509CertificateType (44)
	virtual int soap_type(void) const { return 44; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns5__X509CertificateType, default initialized and not managed by a soap context
	virtual ns5__X509CertificateType *soap_alloc(void) const { return SOAP_NEW(ns5__X509CertificateType); }
	         ns5__X509CertificateType() { ns5__X509CertificateType::soap_default(NULL); }
	virtual ~ns5__X509CertificateType() { }
	friend SOAP_FMAC1 ns5__X509CertificateType * SOAP_FMAC2 soap_instantiate_ns5__X509CertificateType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:297 */
#ifndef SOAP_TYPE_ns5__DigestValueType
#define SOAP_TYPE_ns5__DigestValueType (45)
/* ns5:DigestValueType simple type: */
class SOAP_CMAC ns5__DigestValueType
{
public:
	xsd__base64Binary __item;	/* mixed XML content */
	std::string *Id;	/* optional attribute of XSD type xsd:ID */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns5__DigestValueType (45)
	virtual int soap_type(void) const { return 45; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns5__DigestValueType, default initialized and not managed by a soap context
	virtual ns5__DigestValueType *soap_alloc(void) const { return SOAP_NEW(ns5__DigestValueType); }
	         ns5__DigestValueType() { ns5__DigestValueType::soap_default(NULL); }
	virtual ~ns5__DigestValueType() { }
	friend SOAP_FMAC1 ns5__DigestValueType * SOAP_FMAC2 soap_instantiate_ns5__DigestValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:300 */
#ifndef SOAP_TYPE_ns5__SignatureValueType
#define SOAP_TYPE_ns5__SignatureValueType (46)
/* ns5:SignatureValueType simple type: */
class SOAP_CMAC ns5__SignatureValueType
{
public:
	xsd__base64Binary __item;	/* mixed XML content */
	std::string Id;	/* required attribute of XSD type xsd:ID */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns5__SignatureValueType (46)
	virtual int soap_type(void) const { return 46; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns5__SignatureValueType, default initialized and not managed by a soap context
	virtual ns5__SignatureValueType *soap_alloc(void) const { return SOAP_NEW(ns5__SignatureValueType); }
	         ns5__SignatureValueType() { ns5__SignatureValueType::soap_default(NULL); }
	virtual ~ns5__SignatureValueType() { }
	friend SOAP_FMAC1 ns5__SignatureValueType * SOAP_FMAC2 soap_instantiate_ns5__SignatureValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:414 */
#ifndef SOAP_TYPE_ns1__EncapsulatedX509CertificateType
#define SOAP_TYPE_ns1__EncapsulatedX509CertificateType (84)
/* ns1:EncapsulatedX509CertificateType simple type: */
class SOAP_CMAC ns1__EncapsulatedX509CertificateType
{
public:
	xsd__base64Binary __item;	/* mixed XML content */
	std::string Id;	/* required attribute of XSD type xsd:ID */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__EncapsulatedX509CertificateType (84)
	virtual int soap_type(void) const { return 84; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__EncapsulatedX509CertificateType, default initialized and not managed by a soap context
	virtual ns1__EncapsulatedX509CertificateType *soap_alloc(void) const { return SOAP_NEW(ns1__EncapsulatedX509CertificateType); }
	         ns1__EncapsulatedX509CertificateType() { ns1__EncapsulatedX509CertificateType::soap_default(NULL); }
	virtual ~ns1__EncapsulatedX509CertificateType() { }
	friend SOAP_FMAC1 ns1__EncapsulatedX509CertificateType * SOAP_FMAC2 soap_instantiate_ns1__EncapsulatedX509CertificateType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:423 */
#ifndef SOAP_TYPE_ns1__EncapsulatedCRLValueType
#define SOAP_TYPE_ns1__EncapsulatedCRLValueType (87)
/* ns1:EncapsulatedCRLValueType simple type: */
class SOAP_CMAC ns1__EncapsulatedCRLValueType
{
public:
	xsd__base64Binary __item;	/* mixed XML content */
	std::string Id;	/* required attribute of XSD type xsd:ID */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__EncapsulatedCRLValueType (87)
	virtual int soap_type(void) const { return 87; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__EncapsulatedCRLValueType, default initialized and not managed by a soap context
	virtual ns1__EncapsulatedCRLValueType *soap_alloc(void) const { return SOAP_NEW(ns1__EncapsulatedCRLValueType); }
	         ns1__EncapsulatedCRLValueType() { ns1__EncapsulatedCRLValueType::soap_default(NULL); }
	virtual ~ns1__EncapsulatedCRLValueType() { }
	friend SOAP_FMAC1 ns1__EncapsulatedCRLValueType * SOAP_FMAC2 soap_instantiate_ns1__EncapsulatedCRLValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:429 */
#ifndef SOAP_TYPE_ns1__EncapsulatedOCSPValueType
#define SOAP_TYPE_ns1__EncapsulatedOCSPValueType (89)
/* ns1:EncapsulatedOCSPValueType simple type: */
class SOAP_CMAC ns1__EncapsulatedOCSPValueType
{
public:
	xsd__base64Binary __item;	/* mixed XML content */
	std::string Id;	/* required attribute of XSD type xsd:ID */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns1__EncapsulatedOCSPValueType (89)
	virtual int soap_type(void) const { return 89; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns1__EncapsulatedOCSPValueType, default initialized and not managed by a soap context
	virtual ns1__EncapsulatedOCSPValueType *soap_alloc(void) const { return SOAP_NEW(ns1__EncapsulatedOCSPValueType); }
	         ns1__EncapsulatedOCSPValueType() { ns1__EncapsulatedOCSPValueType::soap_default(NULL); }
	virtual ~ns1__EncapsulatedOCSPValueType() { }
	friend SOAP_FMAC1 ns1__EncapsulatedOCSPValueType * SOAP_FMAC2 soap_instantiate_ns1__EncapsulatedOCSPValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa.h:94 */
#ifndef SOAP_TYPE_wsa__EndpointReferenceType
#define SOAP_TYPE_wsa__EndpointReferenceType (306)
/* wsa:EndpointReferenceType complex type: */
struct wsa__EndpointReferenceType
{
public:
	char *Address;	/* required element of XSD type xsd:string */
	struct wsa__ReferencePropertiesType *ReferenceProperties;	/* optional element of XSD type wsa:ReferencePropertiesType */
	struct wsa__ReferenceParametersType *ReferenceParameters;	/* optional element of XSD type wsa:ReferenceParametersType */
	char **PortType;	/* optional element of XSD type xsd:QName */
	struct wsa__ServiceNameType *ServiceName;	/* optional element of XSD type wsa:ServiceNameType */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char **__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	int soap_type() const { return 306; } /* = unique type id SOAP_TYPE_wsa__EndpointReferenceType */
	         wsa__EndpointReferenceType();
	friend SOAP_FMAC1 wsa__EndpointReferenceType * SOAP_FMAC2 soap_instantiate_wsa__EndpointReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa.h:97 */
#ifndef SOAP_TYPE_wsa__ReferencePropertiesType
#define SOAP_TYPE_wsa__ReferencePropertiesType (307)
/* wsa:ReferencePropertiesType complex type: */
struct wsa__ReferencePropertiesType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char **__any;
public:
	int soap_type() const { return 307; } /* = unique type id SOAP_TYPE_wsa__ReferencePropertiesType */
	         wsa__ReferencePropertiesType();
	friend SOAP_FMAC1 wsa__ReferencePropertiesType * SOAP_FMAC2 soap_instantiate_wsa__ReferencePropertiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa.h:100 */
#ifndef SOAP_TYPE_wsa__ReferenceParametersType
#define SOAP_TYPE_wsa__ReferenceParametersType (308)
/* wsa:ReferenceParametersType complex type: */
struct wsa__ReferenceParametersType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char **__any;
public:
	int soap_type() const { return 308; } /* = unique type id SOAP_TYPE_wsa__ReferenceParametersType */
	         wsa__ReferenceParametersType();
	friend SOAP_FMAC1 wsa__ReferenceParametersType * SOAP_FMAC2 soap_instantiate_wsa__ReferenceParametersType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa.h:103 */
#ifndef SOAP_TYPE_wsa__ServiceNameType
#define SOAP_TYPE_wsa__ServiceNameType (309)
/* wsa:ServiceNameType simple type: */
struct wsa__ServiceNameType
{
public:
	char *__item;	/* mixed XML content */
	char *PortName;	/* optional attribute of XSD type xsd:string */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	int soap_type() const { return 309; } /* = unique type id SOAP_TYPE_wsa__ServiceNameType */
	         wsa__ServiceNameType();
	friend SOAP_FMAC1 wsa__ServiceNameType * SOAP_FMAC2 soap_instantiate_wsa__ServiceNameType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa.h:106 */
#ifndef SOAP_TYPE_wsa__Relationship
#define SOAP_TYPE_wsa__Relationship (310)
/* wsa:Relationship simple type: */
struct wsa__Relationship
{
public:
	char *__item;	/* mixed XML content */
	char *RelationshipType;	/* optional attribute of XSD type xsd:QName */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	int soap_type() const { return 310; } /* = unique type id SOAP_TYPE_wsa__Relationship */
	         wsa__Relationship();
	friend SOAP_FMAC1 wsa__Relationship * SOAP_FMAC2 soap_instantiate_wsa__Relationship(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa.h:250 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (327)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	char *wsa__MessageID;	/* optional element of XSD type wsa:MessageID */
	struct wsa__Relationship *wsa__RelatesTo;	/* optional element of XSD type wsa:RelatesTo */
	struct wsa__EndpointReferenceType *wsa__From;	/* optional element of XSD type wsa:From */
	struct wsa__EndpointReferenceType *wsa__ReplyTo;	/* mustUnderstand */
	struct wsa__EndpointReferenceType *wsa__FaultTo;	/* mustUnderstand */
	char *wsa__To;	/* mustUnderstand */
	char *wsa__Action;	/* mustUnderstand */
public:
	int soap_type() const { return 327; } /* = unique type id SOAP_TYPE_SOAP_ENV__Header */
	         SOAP_ENV__Header();
	friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa.h:266 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (332)
/* SOAP-ENV:Detail complex type: */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below)
	   WARNING: do not create a cyclic data structure graph throught this element unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
	void *fault;	/* transient (not serialized) */
public:
	int soap_type() const { return 332; } /* = unique type id SOAP_TYPE_SOAP_ENV__Detail */
	         SOAP_ENV__Detail();
	friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa.h:267 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (334)
/* Type SOAP_ENV__Code is a recursive data type (in)directly referencing itself through its (base) class members */
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of XSD type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of XSD type SOAP-ENV:Code */
public:
	int soap_type() const { return 334; } /* = unique type id SOAP_TYPE_SOAP_ENV__Code */
	         SOAP_ENV__Code();
	friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa.h:268 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (336)
/* SOAP-ENV:Reason complex type: */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of XSD type xsd:string */
public:
	int soap_type() const { return 336; } /* = unique type id SOAP_TYPE_SOAP_ENV__Reason */
	         SOAP_ENV__Reason();
	friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa.h:273 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (340)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of XSD type xsd:QName */
	char *faultstring;	/* optional element of XSD type xsd:string */
	char *faultactor;	/* optional element of XSD type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of XSD type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of XSD type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of XSD type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of XSD type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of XSD type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of XSD type SOAP-ENV:Detail */
public:
	int soap_type() const { return 340; } /* = unique type id SOAP_TYPE_SOAP_ENV__Fault */
	         SOAP_ENV__Fault();
	friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* SCAP-Services.h:3251 */
#ifndef SOAP_TYPE___ns1__Attributes
#define SOAP_TYPE___ns1__Attributes (344)
/* Operation wrapper: */
struct __ns1__Attributes
{
public:
	ns2__AttributeRequestType *ns2__AttributeRequest;	/* optional element of XSD type ns2:AttributeRequestType */
public:
	int soap_type() const { return 344; } /* = unique type id SOAP_TYPE___ns1__Attributes */
	         __ns1__Attributes();
	friend SOAP_FMAC1 __ns1__Attributes * SOAP_FMAC2 soap_instantiate___ns1__Attributes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:3332 */
#ifndef SOAP_TYPE___ns2__AttributeSuppliers
#define SOAP_TYPE___ns2__AttributeSuppliers (347)
/* Operation wrapper: */
struct __ns2__AttributeSuppliers
{
public:
	int soap_type() const { return 347; } /* = unique type id SOAP_TYPE___ns2__AttributeSuppliers */
	         __ns2__AttributeSuppliers();
	friend SOAP_FMAC1 __ns2__AttributeSuppliers * SOAP_FMAC2 soap_instantiate___ns2__AttributeSuppliers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:3416 */
#ifndef SOAP_TYPE___ns4__Sign
#define SOAP_TYPE___ns4__Sign (351)
/* Operation wrapper: */
struct __ns4__Sign
{
public:
	ns4__SignRequest *ns4__SignRequest_;	/* optional element of XSD type ns4:SignRequest */
public:
	int soap_type() const { return 351; } /* = unique type id SOAP_TYPE___ns4__Sign */
	         __ns4__Sign();
	friend SOAP_FMAC1 __ns4__Sign * SOAP_FMAC2 soap_instantiate___ns4__Sign(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* SCAP-Services.h:101 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

/* SCAP-Services.h:101 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

/* SCAP-Services.h:205 */
#ifndef SOAP_TYPE_xsd__ID
#define SOAP_TYPE_xsd__ID (17)
typedef std::string xsd__ID;
#endif

/* SCAP-Services.h:208 */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (18)
typedef std::string xsd__anyURI;
#endif

/* SCAP-Services.h:211 */
#ifndef SOAP_TYPE_xsd__date
#define SOAP_TYPE_xsd__date (19)
typedef std::string xsd__date;
#endif

/* SCAP-Services.h:214 */
#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (20)
typedef std::string xsd__integer;
#endif

/* SCAP-Services.h:435 */
#ifndef SOAP_TYPE__ns1__Issuer
#define SOAP_TYPE__ns1__Issuer (91)
typedef _XML _ns1__Issuer;
#endif

/* SCAP-Services.h:438 */
#ifndef SOAP_TYPE__ns1__IssueTime
#define SOAP_TYPE__ns1__IssueTime (92)
typedef _XML _ns1__IssueTime;
#endif

/* SCAP-Services.h:441 */
#ifndef SOAP_TYPE__ns1__Number
#define SOAP_TYPE__ns1__Number (93)
typedef _XML _ns1__Number;
#endif

/* SCAP-Services.h:444 */
#ifndef SOAP_TYPE__ns1__ByName
#define SOAP_TYPE__ns1__ByName (94)
typedef _XML _ns1__ByName;
#endif

/* SCAP-Services.h:447 */
#ifndef SOAP_TYPE__ns1__ProducedAt
#define SOAP_TYPE__ns1__ProducedAt (95)
typedef _XML _ns1__ProducedAt;
#endif

/* SCAP-Services.h:570 */
#ifndef SOAP_TYPE_ns5__X509IssuerNameType
#define SOAP_TYPE_ns5__X509IssuerNameType (109)
typedef std::string ns5__X509IssuerNameType;
#endif

/* SCAP-Services.h:574 */
#ifndef SOAP_TYPE_ns5__X509SerialNumberType
#define SOAP_TYPE_ns5__X509SerialNumberType (110)
typedef xsd__integer ns5__X509SerialNumberType;
#endif

/* SCAP-Services.h:595 */
#ifndef SOAP_TYPE_ns4__ProcessIDType
#define SOAP_TYPE_ns4__ProcessIDType (111)
typedef std::string ns4__ProcessIDType;
#endif

/* SCAP-Services.h:600 */
#ifndef SOAP_TYPE_ns4__NameType
#define SOAP_TYPE_ns4__NameType (112)
typedef std::string ns4__NameType;
#endif

/* SCAP-Services.h:604 */
#ifndef SOAP_TYPE_ns4__ValidityType
#define SOAP_TYPE_ns4__ValidityType (113)
typedef xsd__date ns4__ValidityType;
#endif

/* SCAP-Services.h:608 */
#ifndef SOAP_TYPE_ns4__DateType
#define SOAP_TYPE_ns4__DateType (114)
typedef xsd__date ns4__DateType;
#endif

/* SCAP-Services.h:613 */
#ifndef SOAP_TYPE_ns4__NICType
#define SOAP_TYPE_ns4__NICType (115)
typedef std::string ns4__NICType;
#endif

/* SCAP-Services.h:618 */
#ifndef SOAP_TYPE_ns4__NIPCType
#define SOAP_TYPE_ns4__NIPCType (116)
typedef std::string ns4__NIPCType;
#endif

/* SCAP-Services.h:623 */
#ifndef SOAP_TYPE_ns4__CompanyNameType
#define SOAP_TYPE_ns4__CompanyNameType (117)
typedef std::string ns4__CompanyNameType;
#endif

/* SCAP-Services.h:628 */
#ifndef SOAP_TYPE_ns4__ExtraIDValueType
#define SOAP_TYPE_ns4__ExtraIDValueType (118)
typedef std::string ns4__ExtraIDValueType;
#endif

/* SCAP-Services.h:633 */
#ifndef SOAP_TYPE_ns4__AttributeIDType
#define SOAP_TYPE_ns4__AttributeIDType (119)
typedef std::string ns4__AttributeIDType;
#endif

/* SCAP-Services.h:638 */
#ifndef SOAP_TYPE_ns4__LegalActType
#define SOAP_TYPE_ns4__LegalActType (120)
typedef std::string ns4__LegalActType;
#endif

/* SCAP-Services.h:643 */
#ifndef SOAP_TYPE_ns4__SubAttributeValueType
#define SOAP_TYPE_ns4__SubAttributeValueType (121)
typedef std::string ns4__SubAttributeValueType;
#endif

/* SCAP-Services.h:648 */
#ifndef SOAP_TYPE_ns4__DescriptionType
#define SOAP_TYPE_ns4__DescriptionType (122)
typedef std::string ns4__DescriptionType;
#endif

/* SCAP-Services.h:653 */
#ifndef SOAP_TYPE_ns4__ResponseCodeType
#define SOAP_TYPE_ns4__ResponseCodeType (123)
typedef std::string ns4__ResponseCodeType;
#endif

/* SCAP-Services.h:658 */
#ifndef SOAP_TYPE_ns4__ResponseCodeMessage
#define SOAP_TYPE_ns4__ResponseCodeMessage (124)
typedef std::string ns4__ResponseCodeMessage;
#endif

/* SCAP-Services.h:670 */
#ifndef SOAP_TYPE_ns1__SigningTimeType
#define SOAP_TYPE_ns1__SigningTimeType (126)
typedef time_t ns1__SigningTimeType;
#endif

/* SCAP-Services.h:674 */
#ifndef SOAP_TYPE_ns1__EncapsulatedTimeStampType
#define SOAP_TYPE_ns1__EncapsulatedTimeStampType (127)
typedef xsd__base64Binary ns1__EncapsulatedTimeStampType;
#endif

/* SCAP-Services.h:678 */
#ifndef SOAP_TYPE_ns1__IssuerType
#define SOAP_TYPE_ns1__IssuerType (128)
typedef std::string ns1__IssuerType;
#endif

/* SCAP-Services.h:682 */
#ifndef SOAP_TYPE_ns1__IssueTimeType
#define SOAP_TYPE_ns1__IssueTimeType (129)
typedef time_t ns1__IssueTimeType;
#endif

/* SCAP-Services.h:686 */
#ifndef SOAP_TYPE_ns1__NumberType
#define SOAP_TYPE_ns1__NumberType (130)
typedef xsd__integer ns1__NumberType;
#endif

/* SCAP-Services.h:690 */
#ifndef SOAP_TYPE_ns1__ByNameType
#define SOAP_TYPE_ns1__ByNameType (131)
typedef std::string ns1__ByNameType;
#endif

/* SCAP-Services.h:694 */
#ifndef SOAP_TYPE_ns1__ProducedAtType
#define SOAP_TYPE_ns1__ProducedAtType (132)
typedef time_t ns1__ProducedAtType;
#endif

/* SCAP-Services.h:706 */
#ifndef SOAP_TYPE_ns7__SVGType
#define SOAP_TYPE_ns7__SVGType (133)
typedef xsd__base64Binary ns7__SVGType;
#endif

/* SCAP-Services.h:2737 */
#ifndef SOAP_TYPE__ns2__AttributeRequest
#define SOAP_TYPE__ns2__AttributeRequest (243)
typedef ns2__AttributeRequestType _ns2__AttributeRequest;
#endif

/* SCAP-Services.h:2740 */
#ifndef SOAP_TYPE__ns2__AttributeResponse
#define SOAP_TYPE__ns2__AttributeResponse (244)
typedef ns2__AttributeResponseType _ns2__AttributeResponse;
#endif

/* SCAP-Services.h:2743 */
#ifndef SOAP_TYPE__ns2__PSAAttributeRequest
#define SOAP_TYPE__ns2__PSAAttributeRequest (245)
typedef ns2__PSAAttributeRequestType _ns2__PSAAttributeRequest;
#endif

/* SCAP-Services.h:2746 */
#ifndef SOAP_TYPE__ns2__SingleAttributeResponse
#define SOAP_TYPE__ns2__SingleAttributeResponse (246)
typedef ns2__SingleAttributeResponseType _ns2__SingleAttributeResponse;
#endif

/* SCAP-Services.h:2765 */
#ifndef SOAP_TYPE__ns5__Signature
#define SOAP_TYPE__ns5__Signature (247)
typedef ns5__SignatureType _ns5__Signature;
#endif

/* SCAP-Services.h:2768 */
#ifndef SOAP_TYPE__ns5__SignedInfo
#define SOAP_TYPE__ns5__SignedInfo (248)
typedef ns5__SignedInfoType _ns5__SignedInfo;
#endif

/* SCAP-Services.h:2771 */
#ifndef SOAP_TYPE__ns5__CanonicalizationMethod
#define SOAP_TYPE__ns5__CanonicalizationMethod (249)
typedef ns5__CanonicalizationMethodType _ns5__CanonicalizationMethod;
#endif

/* SCAP-Services.h:2774 */
#ifndef SOAP_TYPE__ns5__SignatureMethod
#define SOAP_TYPE__ns5__SignatureMethod (250)
typedef ns5__SignatureMethodType _ns5__SignatureMethod;
#endif

/* SCAP-Services.h:2777 */
#ifndef SOAP_TYPE__ns5__Reference
#define SOAP_TYPE__ns5__Reference (251)
typedef ns5__ReferenceType _ns5__Reference;
#endif

/* SCAP-Services.h:2780 */
#ifndef SOAP_TYPE__ns5__Transforms
#define SOAP_TYPE__ns5__Transforms (252)
typedef ns5__TransformsType _ns5__Transforms;
#endif

/* SCAP-Services.h:2783 */
#ifndef SOAP_TYPE__ns5__Transform
#define SOAP_TYPE__ns5__Transform (253)
typedef ns5__TransformType _ns5__Transform;
#endif

/* SCAP-Services.h:2786 */
#ifndef SOAP_TYPE__ns5__DigestMethod
#define SOAP_TYPE__ns5__DigestMethod (254)
typedef ns5__DigestMethodType _ns5__DigestMethod;
#endif

/* SCAP-Services.h:2789 */
#ifndef SOAP_TYPE__ns5__KeyInfo
#define SOAP_TYPE__ns5__KeyInfo (255)
typedef ns5__KeyInfoType _ns5__KeyInfo;
#endif

/* SCAP-Services.h:2792 */
#ifndef SOAP_TYPE__ns5__X509Data
#define SOAP_TYPE__ns5__X509Data (256)
typedef ns5__X509DataType _ns5__X509Data;
#endif

/* SCAP-Services.h:2795 */
#ifndef SOAP_TYPE__ns5__Object
#define SOAP_TYPE__ns5__Object (257)
typedef ns5__ObjectType _ns5__Object;
#endif

/* SCAP-Services.h:2798 */
#ifndef SOAP_TYPE__ns5__X509Certificate
#define SOAP_TYPE__ns5__X509Certificate (258)
typedef ns5__X509CertificateType _ns5__X509Certificate;
#endif

/* SCAP-Services.h:2801 */
#ifndef SOAP_TYPE__ns5__DigestValue
#define SOAP_TYPE__ns5__DigestValue (259)
typedef ns5__DigestValueType _ns5__DigestValue;
#endif

/* SCAP-Services.h:2804 */
#ifndef SOAP_TYPE__ns5__SignatureValue
#define SOAP_TYPE__ns5__SignatureValue (260)
typedef ns5__SignatureValueType _ns5__SignatureValue;
#endif

/* SCAP-Services.h:2807 */
#ifndef SOAP_TYPE__ns5__X509IssuerName
#define SOAP_TYPE__ns5__X509IssuerName (261)
typedef ns5__X509IssuerNameType _ns5__X509IssuerName;
#endif

/* SCAP-Services.h:2810 */
#ifndef SOAP_TYPE__ns5__X509SerialNumber
#define SOAP_TYPE__ns5__X509SerialNumber (262)
typedef ns5__X509SerialNumberType _ns5__X509SerialNumber;
#endif

/* SCAP-Services.h:2829 */
#ifndef SOAP_TYPE__ns3__Attribute
#define SOAP_TYPE__ns3__Attribute (263)
typedef ns3__AttributeType _ns3__Attribute;
#endif

/* SCAP-Services.h:2832 */
#ifndef SOAP_TYPE__ns3__SignatureAttribute
#define SOAP_TYPE__ns3__SignatureAttribute (264)
typedef ns5__SignatureType _ns3__SignatureAttribute;
#endif

/* SCAP-Services.h:2867 */
#ifndef SOAP_TYPE__ns1__QualifyingProperties
#define SOAP_TYPE__ns1__QualifyingProperties (265)
typedef ns1__QualifyingPropertiesType _ns1__QualifyingProperties;
#endif

/* SCAP-Services.h:2870 */
#ifndef SOAP_TYPE__ns1__SignedProperties
#define SOAP_TYPE__ns1__SignedProperties (266)
typedef ns1__SignedPropertiesType _ns1__SignedProperties;
#endif

/* SCAP-Services.h:2873 */
#ifndef SOAP_TYPE__ns1__SignedSignatureProperties
#define SOAP_TYPE__ns1__SignedSignatureProperties (267)
typedef ns1__SignedSignaturePropertiesType _ns1__SignedSignatureProperties;
#endif

/* SCAP-Services.h:2876 */
#ifndef SOAP_TYPE__ns1__SigningCertificate
#define SOAP_TYPE__ns1__SigningCertificate (268)
typedef ns1__SigningCertificateType _ns1__SigningCertificate;
#endif

/* SCAP-Services.h:2879 */
#ifndef SOAP_TYPE__ns1__Cert
#define SOAP_TYPE__ns1__Cert (269)
typedef ns1__CertType _ns1__Cert;
#endif

/* SCAP-Services.h:2882 */
#ifndef SOAP_TYPE__ns1__CertDigest
#define SOAP_TYPE__ns1__CertDigest (270)
typedef ns1__CertDigestType _ns1__CertDigest;
#endif

/* SCAP-Services.h:2885 */
#ifndef SOAP_TYPE__ns1__IssuerSerial
#define SOAP_TYPE__ns1__IssuerSerial (271)
typedef ns1__IssuerSerialType _ns1__IssuerSerial;
#endif

/* SCAP-Services.h:2888 */
#ifndef SOAP_TYPE__ns1__SigningTime
#define SOAP_TYPE__ns1__SigningTime (272)
typedef ns1__SigningTimeType _ns1__SigningTime;
#endif

/* SCAP-Services.h:2891 */
#ifndef SOAP_TYPE__ns1__SignerRole
#define SOAP_TYPE__ns1__SignerRole (273)
typedef ns1__SignerRoleType _ns1__SignerRole;
#endif

/* SCAP-Services.h:2894 */
#ifndef SOAP_TYPE__ns1__ClaimedRoles
#define SOAP_TYPE__ns1__ClaimedRoles (274)
typedef ns1__ClaimedRolesListType _ns1__ClaimedRoles;
#endif

/* SCAP-Services.h:2897 */
#ifndef SOAP_TYPE__ns1__ClaimedRole
#define SOAP_TYPE__ns1__ClaimedRole (275)
typedef ns1__ClaimedRoleType _ns1__ClaimedRole;
#endif

/* SCAP-Services.h:2900 */
#ifndef SOAP_TYPE__ns1__UnsignedProperties
#define SOAP_TYPE__ns1__UnsignedProperties (276)
typedef ns1__UnsignedPropertiesType _ns1__UnsignedProperties;
#endif

/* SCAP-Services.h:2903 */
#ifndef SOAP_TYPE__ns1__UnsignedSignatureProperties
#define SOAP_TYPE__ns1__UnsignedSignatureProperties (277)
typedef ns1__UnsignedSignaturePropertiesType _ns1__UnsignedSignatureProperties;
#endif

/* SCAP-Services.h:2906 */
#ifndef SOAP_TYPE__ns1__CounterSignature
#define SOAP_TYPE__ns1__CounterSignature (278)
typedef ns1__CounterSignatureType _ns1__CounterSignature;
#endif

/* SCAP-Services.h:2909 */
#ifndef SOAP_TYPE__ns1__SignatureTimeStamp
#define SOAP_TYPE__ns1__SignatureTimeStamp (279)
typedef ns1__SignatureTimeStampType _ns1__SignatureTimeStamp;
#endif

/* SCAP-Services.h:2912 */
#ifndef SOAP_TYPE__ns1__EncapsulatedTimeStamp
#define SOAP_TYPE__ns1__EncapsulatedTimeStamp (280)
typedef ns1__EncapsulatedTimeStampType _ns1__EncapsulatedTimeStamp;
#endif

/* SCAP-Services.h:2915 */
#ifndef SOAP_TYPE__ns1__CompleteCertificateRefs
#define SOAP_TYPE__ns1__CompleteCertificateRefs (281)
typedef ns1__CompleteCertificateRefsType _ns1__CompleteCertificateRefs;
#endif

/* SCAP-Services.h:2918 */
#ifndef SOAP_TYPE__ns1__CertRefs
#define SOAP_TYPE__ns1__CertRefs (282)
typedef ns1__CertRefsType _ns1__CertRefs;
#endif

/* SCAP-Services.h:2921 */
#ifndef SOAP_TYPE__ns1__CompleteRevocationRefs
#define SOAP_TYPE__ns1__CompleteRevocationRefs (283)
typedef ns1__CompleteRevocationRefsType _ns1__CompleteRevocationRefs;
#endif

/* SCAP-Services.h:2924 */
#ifndef SOAP_TYPE__ns1__CRLRefs
#define SOAP_TYPE__ns1__CRLRefs (284)
typedef ns1__CRLRefsType _ns1__CRLRefs;
#endif

/* SCAP-Services.h:2927 */
#ifndef SOAP_TYPE__ns1__CRLRef
#define SOAP_TYPE__ns1__CRLRef (285)
typedef ns1__CRLRefType _ns1__CRLRef;
#endif

/* SCAP-Services.h:2930 */
#ifndef SOAP_TYPE__ns1__DigestAlgAndValue
#define SOAP_TYPE__ns1__DigestAlgAndValue (286)
typedef ns1__DigestAlgAndValueType _ns1__DigestAlgAndValue;
#endif

/* SCAP-Services.h:2933 */
#ifndef SOAP_TYPE__ns1__CRLIdentifier
#define SOAP_TYPE__ns1__CRLIdentifier (287)
typedef ns1__CRLIdentifierType _ns1__CRLIdentifier;
#endif

/* SCAP-Services.h:2936 */
#ifndef SOAP_TYPE__ns1__OCSPRefs
#define SOAP_TYPE__ns1__OCSPRefs (288)
typedef ns1__OCSPRefsType _ns1__OCSPRefs;
#endif

/* SCAP-Services.h:2939 */
#ifndef SOAP_TYPE__ns1__OCSPRef
#define SOAP_TYPE__ns1__OCSPRef (289)
typedef ns1__OCSPRefType _ns1__OCSPRef;
#endif

/* SCAP-Services.h:2942 */
#ifndef SOAP_TYPE__ns1__OCSPIdentifier
#define SOAP_TYPE__ns1__OCSPIdentifier (290)
typedef ns1__OCSPIdentifierType _ns1__OCSPIdentifier;
#endif

/* SCAP-Services.h:2945 */
#ifndef SOAP_TYPE__ns1__ResponderID
#define SOAP_TYPE__ns1__ResponderID (291)
typedef ns1__ResponderIDType _ns1__ResponderID;
#endif

/* SCAP-Services.h:2948 */
#ifndef SOAP_TYPE__ns1__SigAndRefsTimeStamp
#define SOAP_TYPE__ns1__SigAndRefsTimeStamp (292)
typedef ns1__SigAndRefsTimeStampType _ns1__SigAndRefsTimeStamp;
#endif

/* SCAP-Services.h:2951 */
#ifndef SOAP_TYPE__ns1__CertificateValues
#define SOAP_TYPE__ns1__CertificateValues (293)
typedef ns1__CertificateValuesType _ns1__CertificateValues;
#endif

/* SCAP-Services.h:2954 */
#ifndef SOAP_TYPE__ns1__EncapsulatedX509Certificate
#define SOAP_TYPE__ns1__EncapsulatedX509Certificate (294)
typedef ns1__EncapsulatedX509CertificateType _ns1__EncapsulatedX509Certificate;
#endif

/* SCAP-Services.h:2957 */
#ifndef SOAP_TYPE__ns1__RevocationValues
#define SOAP_TYPE__ns1__RevocationValues (295)
typedef ns1__RevocationValuesType _ns1__RevocationValues;
#endif

/* SCAP-Services.h:2960 */
#ifndef SOAP_TYPE__ns1__CRLValues
#define SOAP_TYPE__ns1__CRLValues (296)
typedef ns1__CRLValuesType _ns1__CRLValues;
#endif

/* SCAP-Services.h:2963 */
#ifndef SOAP_TYPE__ns1__EncapsulatedCRLValue
#define SOAP_TYPE__ns1__EncapsulatedCRLValue (297)
typedef ns1__EncapsulatedCRLValueType _ns1__EncapsulatedCRLValue;
#endif

/* SCAP-Services.h:2966 */
#ifndef SOAP_TYPE__ns1__OCSPValues
#define SOAP_TYPE__ns1__OCSPValues (298)
typedef ns1__OCSPValuesType _ns1__OCSPValues;
#endif

/* SCAP-Services.h:2969 */
#ifndef SOAP_TYPE__ns1__EncapsulatedOCSPValue
#define SOAP_TYPE__ns1__EncapsulatedOCSPValue (299)
typedef ns1__EncapsulatedOCSPValueType _ns1__EncapsulatedOCSPValue;
#endif

/* SCAP-Services.h:2972 */
#ifndef SOAP_TYPE__ns1__ArchiveTimeStamp
#define SOAP_TYPE__ns1__ArchiveTimeStamp (300)
typedef ns1__ArchiveTimeStampType _ns1__ArchiveTimeStamp;
#endif

/* SCAP-Services.h:2991 */
#ifndef SOAP_TYPE__ns7__SVGList
#define SOAP_TYPE__ns7__SVGList (301)
typedef ns7__SVGListType _ns7__SVGList;
#endif

/* SCAP-Services.h:2994 */
#ifndef SOAP_TYPE__ns7__SVG
#define SOAP_TYPE__ns7__SVG (302)
typedef ns7__SVGType _ns7__SVG;
#endif

/* SCAP-Services.h:3029 */
#ifndef SOAP_TYPE__ns3__AttributeSupplierResponse
#define SOAP_TYPE__ns3__AttributeSupplierResponse (303)
typedef ns3__AttributeSupplierResponseType _ns3__AttributeSupplierResponse;
#endif

/* SCAP-Services.h:3048 */
#ifndef SOAP_TYPE__ns4__SignRequest
#define SOAP_TYPE__ns4__SignRequest (304)
typedef ns4__SignRequest _ns4__SignRequest;
#endif

/* SCAP-Services.h:3051 */
#ifndef SOAP_TYPE__ns4__SignResponse
#define SOAP_TYPE__ns4__SignResponse (305)
typedef ns4__SignResponse _ns4__SignResponse;
#endif

/* wsa.h:220 */
#ifndef SOAP_TYPE__wsa__EndpointReference
#define SOAP_TYPE__wsa__EndpointReference (318)
typedef struct wsa__EndpointReferenceType _wsa__EndpointReference;
#endif

/* wsa.h:223 */
#ifndef SOAP_TYPE__wsa__MessageID
#define SOAP_TYPE__wsa__MessageID (319)
typedef char *_wsa__MessageID;
#endif

/* wsa.h:226 */
#ifndef SOAP_TYPE__wsa__RelatesTo
#define SOAP_TYPE__wsa__RelatesTo (320)
typedef struct wsa__Relationship _wsa__RelatesTo;
#endif

/* wsa.h:229 */
#ifndef SOAP_TYPE__wsa__To
#define SOAP_TYPE__wsa__To (321)
typedef char *_wsa__To;
#endif

/* wsa.h:232 */
#ifndef SOAP_TYPE__wsa__Action
#define SOAP_TYPE__wsa__Action (322)
typedef char *_wsa__Action;
#endif

/* wsa.h:235 */
#ifndef SOAP_TYPE__wsa__From
#define SOAP_TYPE__wsa__From (323)
typedef struct wsa__EndpointReferenceType _wsa__From;
#endif

/* wsa.h:238 */
#ifndef SOAP_TYPE__wsa__ReplyTo
#define SOAP_TYPE__wsa__ReplyTo (324)
typedef struct wsa__EndpointReferenceType _wsa__ReplyTo;
#endif

/* wsa.h:241 */
#ifndef SOAP_TYPE__wsa__FaultTo
#define SOAP_TYPE__wsa__FaultTo (325)
typedef struct wsa__EndpointReferenceType _wsa__FaultTo;
#endif

/* wsa.h:244 */
#ifndef SOAP_TYPE__wsa__ReplyAfter
#define SOAP_TYPE__wsa__ReplyAfter (326)
typedef unsigned int _wsa__ReplyAfter;
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of SCAPStub.h */
